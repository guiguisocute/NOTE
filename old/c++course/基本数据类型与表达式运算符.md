## 基本数据类型与表达式 
--- 

### 常用基本数据类型

#### `int`家族：
|类型|字节长度|数据范围（dec）|备注|
|---------------|:----:|:------------:|:-----:|
|`int`(标准整形)|4|-2147483648~+2147483647|无小数点最常用的数据类型|
|`unsigned`&nbsp;`int`(无符号整型)|4|0~+4294967295|
|`short`&nbsp;`int`（短整形）|2|-32768~+32767|
|`unsigned`&nbsp;`short`&nbsp;`int`(无符号短整型)|2|0~65535|
|`long` `int`(长整型)|4[^1]| -2147483648~+2147483647|
|`unsigned` `long` `int`(无符号长整型)|4|0~+4294967295|

*注意：指针的长度默认为`unsigned` `long`*
<br>

#### *浮点型* 家族
|类型|字节长度|数据范围&nbsp;（DEC）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|有效数字&nbsp;[^2]|
|---------------|:----:|:------------|:-----:|
|`float`(单精度浮点)|4|3.4x10^-38^~~3.4x10^38^|6~7|
|`double`(双精度浮点)|8|1.7x10^-308^~~1.7x10^308^|15~16|
|`long`&nbsp;`double`（长双精度浮点）|16|-1.2x10^-4932^~1.2x10^4932^|18~19|

***注意：无论最终怎么表示，浮点型在内存中永远是按科学计数法的指数形式储存的***
<br>

#### *字符型* 家族

|类型|字节长度|数据范围（dec）|备注|
|---------------|:----:|:------------:|:-----:|
|`char`(标准字符型)|1|-128~+127|数据范围是指此变量作为 *整数* 的时的数据范围|
|`unsigned`&nbsp;`char`(无符号字符型)|1|0~255|有无符号在变量表达字符时并没有区别，但表达整数时有区别（具体详见[`char`和 `unsigned` `char` 的区别浅析](#jump1)）|

- 字符型与整数密切相关，因为它们在内部其实是被存储为整数。每个可打印的字符以及许多不可打印的字符都被分配一个唯一的数字。（ASCII码），~~btw，java中的`char`型是`unicode`~~
- 如果需要使用字符声明`char`型，则必须用`‘’`括起来，因为这里的字符常数就是赋给变量的值,如：
    ~~~C++
    char LETTER= 'A';
    ~~~
- 常见的ASCII码对应：`'0'＝48　　　　'A'＝65　　　　'a'＝97`
(**ASCII码值中，大小写字母码的关系是对应的大写字母与小写字母之间相差32，大写字母码<小写字母码**)
<br>
##### 字符常数和字符串常数的区别
~~~C++
cout << 'H' << endl;  //这显示的是字符常数
cout << "Hello" << endl; //这显示的是字符串常数
~~~
1. 字符常数使用`''`包裹，字符串常数用`“”`包裹。
2. 字符常数只占用一个字节，而字符串常数可占用无数多个字节
    - 因而，程序必须有一些方法知道它有多长。在 C++ 中，这是通过在其末尾附加一个额外的字节并将数字 0 存储在其中来完成的。这被称为 `null 终止符`或 `null 字符`，它标记着字符串的结尾，这同时也是ASCII码值为0的字符常数
    
        - 这也解释了为什么“abc”占4个字节而不是3
        <br>
3. 有些字符串虽然看起来像是只有一个字符，但实际上并不是。另外，也有一些字符看起来像是字符串，例如换行符` \n`，虽然它由两个字符表示，一个反斜杠和一个控制字符 n，但是它在内部其实只表示一个字符。事实上，所有的[转义序列](#jump2)在内部都只有 1 个字节。

#### 枚举类型
- 枚举类型(enumeration)是C++中的一种派生数据类型，它是由用户定义的**若干枚举常量的集合**。

- 如果一个变量只有几种可能的值，可以定义为枚举(enumeration)类型。所谓"枚举"是指将变量的值一一列举出来，**变量的值只能在列举出来的值的范围内**。

- 创建枚举，需要使用关键字`enum`，枚举类型的一般形式为：
```c
enum 枚举名{ 
     标识符[=整型常数], 
     标识符[=整型常数], 
... 
    标识符 [=整型常数]
} 枚举变量;
```
- 如果枚举没有初始化, 即省掉"=整型常数"时, 则从第一个标识符开始。

例如，下面的代码定义了一个颜色枚举，变量 c 的类型为 color。最后，c 被赋值为 "blue"
```c
enum color { red, green, blue } c;
c = blue;
```
- 和 color 数据类型关联的命名整数常量被称为**枚举量**，color 数据类型的变量可能只是关联到这些枚举量的值之一

- 在枚举量没有初始化的情况下，编译器会默认第一个枚举量为整形0，下一个为1，以此类推，所以在此代码中，red=0，green=1, blue=2。
- **注意：** enum 语句示例实际上**并没有创建任何变量**，只是定义数据类型。当以后创建这个数据类型的变量时，它们看起来就是整数，并且这些整数的值被限制在与枚举集合中的符号名称相关联的整数上。

虽然上面那块代码已经暗中展示了如何定义color数据类型的变量，但本人还是想把他特别标识出来增加一下此笔记的可读性：
```c
color c;
```
- 此语句的形式与其他任何变量定义一样，首先是数据类型名称，然后是变量名称。请注意，数据类型名称是 color，而不是 enum color。
- 声明变量后，当然可以赋值，语句也和整数型的变量基本一致，不过并不用加引号，因为此处的并不是字符串常数,如下
```c
c=blue;
```
- ***重点***：即使枚举数据类型中的值实际存储为整数，也不能总是将整数值替换为符号名称。例如，不能使用`c=2;`把 blue 赋值给 c 。
<br>
- 但是，可以使用整数值而不是符号名称来测试枚举变量。比如关系运算符来比较两个枚举变量的整数值，这是可以的
```c
if (c == blue)
if (c == 2)       //这两个是等价的
if (student1 < student2)        //这个也是可行的，比较的是枚举变量里所代表的整数值
```
- 默认情况下，枚举列表中的符号将被赋给整数值 0、1、2 等等。如果这不合适，则可以指定要赋给的值，如以下示例所示：
```c
enum Department { factory = 1, sales = 2, warehouse = 4 };
```

**请记住，如果为枚举符号赋值，则它们必须是整数。**
- 虽然没有要求按升序排列赋给的整数值，但一般默认是这样。

**作用**：枚举变量的目的之一是有助于使程序自我解释，但是这些名称都不是字符串（不带双引号），所以当时用`cout`进行输出的时候，显示的依然是整数值

- 因为枚举数据类型的符号名称与整数值相关联，所以它们可以在 switch 语句中使用

---

####　typedef 声明
C++非常自由，自由到你也可以使用 typedef 为一个已有的类型取一个新的名字。
下面是使用 typedef 定义一个新类型的语法：

例如，下面的语句会告诉编译器，feet 是 int 的另一个名称：
```c
typedef int feet;
```
现在，下面的声明是完全合法的，它创建了一个整型变量 distance：
```c
feet distance;
```
- **<font color=red>但是`typedef`不同于`#define`宏处理一样是无脑的文本替换，任何声明变量的语句前面加上`typedef`之后，原来是变量的都变成一种类型。不管这个声明中的标识符号出现在中间还是最后。具体用法详见“函数的typedef”这一标题 </font>**
### 运算符与表达式
##### 运算符的定义
运算符是一种告诉编译器执行特定的**数学**或**逻辑**操作的符号。
Cpp提供了以下运算符
- 算术运算符
- 关系运算符
- 杂项运算符
- 位运算符
- 赋值运算符
- 杂项运算符



~~~C++
 #include<iostream>   //后面笔记的AB变量都要如此
 using namespace std;
 int main()
 {
     int a,b,c;
     a=10,b=20;
 }
~~~
#### 算术运算符
|运算符|描述|实例|
|---|----|---|
|+|简单加法|A+B=31|
|-|简单减法|A-B=-10|
|\*|简单乘法|A*B=200|
|/|简单除法^\*^|A/B=**0**
|%|取模运算符，*整除后取余*|A%B=10|
|++|自增运算符，*整数值加一*|A++=11|
|--|自减运算符，*整数值减一*|A--=9|
\*:　除法运算后的结果和两个变量的数据类型息息相关，  
表格中的A,B是`int`所以结果是0*毕竟 `int`没有小数*  
但如果是`double`或者`float`的话，结果就是0.5了

#### 关系运算符
**注意**：在几乎所有的高级语言中，1表示真，0表示假
|运算符|描述|实例|
|:---:|----|---|
|==|检查是否相等，相等为真|（A==B）输出为0|
|!^*^=|检查是否不等，不等为真|（A!=B）输出为1|
|>|检查是否大于，大于为真|（A> B）输出为0|
|<|检查是否小于，小于为真|（A< B）输出为1|
|>=|多加了个等于|略|
|<=|多加了个等于条件|略|
\*：*几乎在所有的高级语言中，`!`在表示关系时都表示“非”的意思*
#### 逻辑运算符
|运算符|描述|实例|
|:---:|----|---|
|`&&`|`逻辑与运算符`,如果两个操作数都非零，则条件为真|A&&B→0|
|`||`|`逻辑或运算符`，如果两个操作数中有任意一个非零，则条件为真|略|
|`!`|`逻辑非运算符`,用来*逆转* 操作数的逻辑状态。如果条件为真则逻辑非运算符将使其为假||
#### 位运算符
>通俗来讲，*位运算符就是二进制的算术运算符*，所谓**按位运算**就是指先将数字转化成二进制数字，然后按照二进制的规则进行相关的运算。
##### 位运算符详细解释

`&`（按位与 *AND*）: 按位与运算符：参与运算的两个值,如果两个相应位都为1,则该位的结果为1,否则为0
例如:   
```C
        0 0 1 1 1 0 1 1
        1 0 1 1 0 1 0 1
     --------------------
        0 0 1 1 0 0 0 1
```
`|` （按位或 OR）: 按位或运算符：只要对应的二个二进位有一个为1时，结果位就为1。
例如:  
```C
        0 1 0 1 0 0 1 1
        1 0 0 1 1 0 0 1
      -------------------
        1 1 0 1 1 0 1 1
```
`~`（按位非）: 按位取反运算符：对数据的每个二进制位取反,即把1变为0,把0变为1
例如:  
```C
        1 1 0 0 1 0 1 0
      ------------------
        0 0 1 1 0 1 0 1
```
`^`（按位异或）: 按位异或运算符：当两对应的二进位相异时，结果为1
例如: 
``` C
        0 0 1 1 0 1 0 1
        0 1 0 1 0 1 0 0
      ------------------
        0 1 1 0 0 0 0 1
```
`<< `(有符号左移位) : 左移动运算符：运算数的各二进位全部左移若干位，由"<<"右边的数指定移动的位数，高位丢弃，低位补0。
例如:  
```C
<< 1    print(6 << 1) # 6 * 2**1
        0 0 1 0 1 0 1 1 
      ------------------
        0 1 0 1 0 1 1 0
```
`>>`（有符号右移位）: 右移动运算符：把">>"左边的运算数的各二进位全部右移若干位，">>"右边的数指定移动的位数，低位丢弃，高位补0
例如:
```C
  >> 1  print(6 >> 1) # 6 // 2**1
        0 1 0 1 0 1 0 1
      ------------------
        0 0 1 0 1 0 1 0
```
##### 位运算符的特点
1. 效率高，内存消耗少 *在老旧的电脑上位运算符效率会大大地大于加减法，但是经过intel的~~挤牙膏~~改进，现在已然和正常整形数据的加减法差别不大了，但还是要大幅度快于乘法除法*
<br>
2. 在某些情况中，位操作可以避免或者减少在一个数据结构上需要进行循环的次数，并且可以成倍的效率提升，
因为位操作是并行处理的。但是位操作的代码比较难以编写和维护。
<br>
3. 唯一的二进制运算符

#### 赋值运算符
|运算符|描述|实例|
|:---:|----|---|
|=|右值赋给左值，最基本的赋值运算符|`A=B`相当于把B值赋给A|
|+=|加且赋值运算符 把右边操作数加上左边操作数的结果赋值给左边操作数|`B+=A`==`B=B+A`|
|-=|减且赋值运算符 把右边操作数减去左边操作数的结果赋值给左边操作数|`B-=A`==`B=B-A`|
|*=|乘且赋值运算符 把右边操作数乘与左边操作数的结果赋值给左边操作数|`B*=A`==`B=B*A`|
|/=|除且赋值运算符，把右边操作数除左边操作数的结果赋值给左边操作数|`B/=A`==`B=B/A`|
|%=|略|略|
|&=|按位与并且赋值|`B&=A`==`B=B&A`|
|^=|略|略|
|\|=|略|略|
|>>=|略|略|
|<<=|略|略|

####　杂项运算符
- 不属于逻辑与算术的任何一类，但任然具有重要功能的运算符
    - 以下是C艹支持的杂项运算符

|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;运算符&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|描述|实例|
|:---:|---|---|
|`sizeof()`|`返回变量的大小运算符`。例如sizeof(a) 将返回 4，其中 a 是整形|sizeof(int)→4|
|`Condition ?X:Y`|`条件运算符`,如果 Condition 为真 ? 则值为 X : 否则值为 Y（？）|c = (a + b == 10) ? a : b;，→c=20|
|`,`|`逗号运算符`会顺序执行一系列运算 整个逗号表达式的值是以逗号分隔的列表中的最后一个表达式的值|`a,b`|
|`.(英文句号的店)`AND`->（箭头）`|成员运算符用于引用类、结构和共用体的成员（？）|（？）|
|cast|`强制转换运算符`，把一种数据类型转换为另一种数据类型。例如，int(2.2000) 将返回 2。|(?)|
|`&`(放在变量前)|`取址运算符`,返回变量的地址，将给出变量的实际地址|&a=0x…………|
|`*`(用在基本数据类型前)|`指针运算符` * 指向一个变量。例如，*var; 将指向变量 var|
|`*`(用在指针类型前)|`取内容运算符` 返回指针所指变量的内容，将给出该所指的实际内容|

#### 运算符的优先级
> 括号>单目>算术>关系>位>逻辑>条件>赋值>逗号

|类别|	运算符|	结合性|
|----|----|----|
|后缀|	() [] -> . ++ - -	|从左到右|
|一元|	+ - ! ~ ++ - - (type)* & sizeof	|从右到左|
|乘除|	* / %	|从左到右|
|加减|	+ -	|从左到右|
|移位|	<< >>	|从左到右|
|关系|	< <= > >=	|从左到右|
|相等|	== !=	|从左到右|
|位与AND|	&	|从左到右|
|位异或OR|	^	|从左到右|
|位或OR|	\||从左到右|
|逻辑与AND|	&&|	从左到右|
|逻辑或OR|	\|\||	从左到右|
|条件|	?:	|从右到左|
|赋值|	= += -= *= /= %=>>= <<= &= ^= \|=	|从右到左|
|逗号|	,	|从左到右|

### 表达式
在程序中，运算符是用来操作数据的，这些数据也被称为`操作数`，使用运算符将操作数连接而成的式子称为：`表达式`
表达式具有如下特点:

- 常量和变量都是表达式
- 运算符的类型对应表达式的类型
- 每一个表达式都有自己的值



## 附录
---
### <span id="jump2">C++的转义序列</span>
|表现形式|意义|
|--|----| 
|\n|换行符|
|\r       |回车符|
|\t        |水平制表符（Tab键）|
|\b      |退格符（BackSpace键）|   
|\\\       |反斜线|
|\'       |单引号|
|\"       |双引号|
|\0     | 空字符|
|\a|响铃|

### <span id="jump1">`char`和`unsigned　char`的区别浅析</span>
- **相同点**：在内存中都是一个字节，8位（2^8^=256），都能表示256个数字
- **不同点**：char的最高位为符号位，因此char能表示的数据范围是-128~127，  unsigned char没有符号位，因此能表示的数据范围是0~255

> **实际使用**中，如普通的赋值，读写文件和网络字节流都没有区别，不管最高位是什么，最终的读取结果都一样，在屏幕上面的显示可能不一样。

>但是要把一个char类型的变量赋值给int、long等数据类型或进行类似的**强制类型转换时**，系统会进行类型扩展，这时区别就大了。对于char类型的变量，系统会认为最高位为符号位，然后对最高位进行扩展，即符号扩展。若最高位为1，则扩展到int时高位都以1填充。对于unsigned char类型的变量，系统会直接进行无符号扩展，即0扩展。扩展的高位都以0填充。所以在进行类似的操作时，如果char和unsigned char最高位都是0，则结果是一样的，若char最高位为1，则结果会大相径庭。
</br>

啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊

*更详细的证明只能见我的收藏夹了*~~程序读不懂啊哼哼哼啊啊啊啊啊~~
[^1]:>int的字节长度，是由硬件和系统共同决定的。 <br> 
dos是运行在16位CPU下的，他的int就是两个字节  <br>
win95是运行在32位CPU下的，但win95还是16位的系统设计，所以他的int还是2个字节  <br>
NT，XP,cpu是32位的，windows也支持32位，所以他的int就是32位的了。语言并没有规定类型的长度  <br>
但是有一些规则，比如：char不论在什么时候都是一个字节（即8个bit）  <br>
int永远比char长，long不会小于int的长度。

[^2]:>有效数字：**浮点型数据的精度 <br>**
float和double的精度是由尾数的位数来决定的。<br>
浮点数在内存中是按科学计数法来存储的，其整数部分始终是一个隐含着的“1”，由于它是不变的，故不能对精度造成影响。<br>
float：2^23 = 8388608，一共七位，这意味着最多能有7位有效数字，但绝对能保证的为6位，<br>
也即float的精度为6~7位有效数字；double：2^52 = 4503599627370496，一共16位，同理，double的精度为15~16位。









