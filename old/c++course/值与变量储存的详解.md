## 值与变量
首先要明确一个概念，值（value）与变量（variable）并不是同一个东西
- 值只有 **类别(category)** 的划分，变量只有 **类型(type)** 的划分。
- 值不一定拥有 **身份(identity)**，也不一定拥有**变量名**（例如 表达式中间结果 `i + j + k`)
### C++ 中的左值（Lvalues）和右值（Rvalues）
C++ 中有两种类型的表达式：

- **左值（lvalue）**：顾名思义，一般情况下常出现在**赋值符号左边的值**.指向内存位置的**表达式**被称为左值（lvalue）表达式。因此左值可以出现在赋值号的左边或右边。准确来说，左值是表达式后依然存在的持久对象
<br>
  - lvalue是我们要赋值的对象。它是一个变量，存在于内存中，它的值可以被改变，**可以被取地址**。任何可以通过它的名字，指针或者引用来接触的变量都是lvalue，例如定义的某个变量和函数的参数， 对一个表达式取地址。
<br>
- **右值（rvalue）**：与左值对应，右边的值，表达式结束后就不再存在的临时对象。指的是存储在内存中某些地址的**数值** 。右值是不能对其进行赋值的表达式，也就是说，右值可以出现在赋值号的右边，但不能出现在赋值号的左边。
<br>
  - rvalue则是一个临时变量，不存在于内存中，存在于CPU的寄存器或者指令的立即数中(immediate number)，因此我们不能改变它的值，**不能取地址**。它们通常是一个直接的数值，运算符返回的数值，**或是函数的返回值**，或者通过隐式类型转换得到的对象
<br>

- **纯右值（prvalue）**： 纯粹的右值，要么是纯粹的字面量，例如` 10, true(布尔型常量)`; 要么是求值结果相当于字面量或匿名临时对象，例如 `1+2`。非引用返回的临时变量、运算表达式产生的临时变量、原始字面量、Lambda 表达式都属于纯右值。

变量是左值，因此可以出现在赋值号的左边。数值型的字面值是右值，因此不能被赋值，不能出现在赋值号的左边。
*后面属实有点过于深奥了，先收藏先*

### 存储特性
#### 变量作用域
通常来说，**一段程序代码中所用到的名字(包括各种变量名，函数名)并不总是有效/可用的**，而限定这个名字的可用性的代码范围就是这个名字的作用域，超过该区域变量就不能被访问，一般来说Cpp有三个地方可以定义变量：

- 在函数或一个代码块内部声明的变量，称为**局部变量**。*形式参数也是储存在动态区域所以也是局部变量*

- 在所有函数外部声明的变量，称为**全局变量**。

- 程序在运行过程中动态申请内存的对象称为**动态对象**
#### 概述
|名称|解释|
|---|---|
|局部变量|在一个函数内部定义的变量（包括函数形参）|
|全局变量|由析构函数先行定义的变量（函数外定义的）|
|静态变量|在定义变量前加上`static`（就算是全局也可以被修饰，虽然都是储存在静态内存区，但是意义有所不同）|
|动态对象|（类相关）在程序运行中动态申请内存的对象（new，malloc）|

|内存区|存放对象|创造时期|销毁时期|
|--|--|--|--|
|栈内存|局部非静态对象|运行到该程序块时分配内存|离开该程序块时销毁|
|静态内存|局部静态对象，类的static成员，所有定义在函数体外的对象|编译开始时分配内存|程序结束时销毁|
|堆内存|动态对象|运行到该程序块时分配内存|**显式的销毁**|

#### 局部变量
在一个函数内部定义的变量（包括函数头，所以形参也属于局部变量）

有效范围（作用域）只在本函数范围内，**也就是说只有在本函数内才能使用它们，在此函数以外是不能使用这些变量的**，

这种类型的变量就称为“局部变量”。

局部变量存储在栈内存，在函数结束后自动销毁

#### 全局变量
在函数外部所定义的变量，可以被本源文件中任意其他的函数给公用

有效范围（作用域）从定义变量开始到本源文件结束

全局变量储存在静态储存区（静态内存）内

全局变量可以被同一工程项目中其他文件用`extern`(外部变量声明)声明后调用，对其每次进行修改都会被保存

#### 静态变量
- **静态局部变量**
	静态局部变量是在原本在函数内定义的局部变量前面加上`static`
	此时变量会存储在静态储存区内，等到整个程序结束才会销毁
	但是它的作用域依然在函数体内部。但是自从静态局部变量被定义后，每次在任何地方对其进行修改都会被保存下来
<br>

- **静态全局变量**
	静态全局变量就是在原先的全局变量前面加上了`static`进行修饰。
	静态全局变量依然存储在静态存储区。
	跟全局变量最大的不同在于，静态全局变量不能被其他源文件使用，**只能被本源文件使用**，对其每次进行修改都会被保存。
#### 动态对象
动态对象是程序运行时分配的对象，例如使用new和malloc分配的对象，这部分对象的生存期由程序来控制，也就是说，动态对象需要我们手动的进行销毁（使用delete和free进行销毁）。动态对象存储在堆区。（~~详细见未来的笔记~~）
#### example codes
```c

#include <iostream>
using namespace std;
 
int global = 100;            //全局变量
 
static int sta_global = 99;   //静态全局变量
 
int P_fun(int **p)
{
	int local = 98;              //局部变量；
	static int sta_local = 97;   //静态局部变量
 
	(*p) = new int[10];         //动态对象；
	for (int i = 0; i < 10;)
	{
		(*p)[i++] = i;
	}
	sta_global--;
	global--;
	cout << "local is" << local << endl;;
	cout << "sta_local is" << sta_local << endl;
	cout << "sta_global is" << sta_global << endl;
	cout << "global is" << global << endl;
	return sta_local--;
}
 
void main()
{
	int *Point;
 
	int times = P_fun(&Point);
	cout << Point[0] << " " << endl;
	cout << endl << endl;
	delete Point;        //释放内存；
 
	times = P_fun(&Point);
	cout << Point[0] << " " << endl;
	cout << endl << endl;
	delete Point;
 
	times = P_fun(&Point);
	cout << Point[0] << " " << endl;
	cout << endl << endl;
 
	delete Point;            
 
	system("pause");
	return;
}
```
从上面的结果可以看出，每次调用P_fun( )后，全局变量，静态全局变量，静态局部变量的值都改变。。而局部变量却没有改变，原因就是在退出P_fun( )后，这些变量没有被销毁，而是被保存了下来。局部变量每次都进行了重新定义，每次的值都是一样的。

这代码狗都读不懂
#### 程序的内存分配（公式八股文）
一个由c/C++编译的程序占用的内存分为以下几个部分:
|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;名称&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|解释|
|---|----|
|栈区（stack）| 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。|
|堆区（动态区）（heap） | 一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收 。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表|
|全局区（静态区）（static）|全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。 - 程序结束后有系统释放|
|文字常量区|常量字符串就是放在这里的。 程序结束后由系统释放|
|程序代码区|存放函数体的二进制代码。|
**example：** 
```c
#include<iostream>
using namespace std;
int a = 0;			//全局初始化区
char *p1;				//全局未初始化区
main()
{
	int b;			//整形变量，栈
	char s[] = "abc";		//数组，栈
	char *p2;			//栈
	char *p3 = "123456";	//123456\0在常量区，p3在栈上。
	static int c =0;		//全局（静态）初始化区
	p1 = (char *)malloc(10);
	p2 = (char *)malloc(20);	//分配得来得10和20字节的区域就在堆区。
	strcpy(p1,"123456");	//123456\0放在常量区，编译器可能会将它与p3所指向的"123456"优化成一个地方
}
```




---
#### 2021年4月28日14:43:29课堂随记




>C++ 中每个变量都有指定的类型，类型决定了变量存储的大小和布局，该范围内的值都可以存储在内存中，运算符可应用于变量上








**标识符**
堆区：编码人员声明的

**储存特性**
堆区：常容易产生内存碎片导致其冗余~~所以java天下第一~~
栈区：函数中的参数和局部变量，自动存储（auto）类型，都放在栈区里
*自动存储类型*
没初始化那就是个随机数
**静态存储类**`static`*加了就是全局区的人了*，//只是另外一个小类罢了
和全局变量区息息相关，
1. 如果没有初始化，自动初始化为0
2. 只初始化一次
3. 记忆功能
4. 没初始化就是0


实际上运行代码也是还要开辟栈的空间的，但是代码确实还是放在代码去的

函数形参的函数原型形式参数表中的标识符具有函数原型`作用域`
**作用域**
文件作用域： 
这种是每个函数都有的
文件作用于的声明（externed）

`全局变量`和`局部变量`
具有文件作用域的变量（函数外声明的变量）→全局变量
在函数或一个代码块内部声明的变量→局部变量
局部变量和全局变量的名称可以相同，但是在函数内，局部变量的值会**覆盖**全局变量的值

#### 编译器工作原理和预编译
（解决方案.clc）
头文件：*声明与常量* 与源文件：*算法与执行* 的互相调用
**C++编译器的工作过程**

预处理→`#`开头的代码,(object)
`#include`，就是一种预处理，<iostream>这里面搜的是固定系统库，""这个是优先搜工作目录（同一个项目）的，而且可以添加路径去搜索

```c
//条件编译
#if conditions
programs
#endif
```
不满足conditions就不编译programs嗷

**宏定义指令**
```c
#ifndef SB_H
  #defineSB_H
  BALABALABLA
#endif
```
**终止程序运行**


