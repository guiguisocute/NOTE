## 基本数据类型与表达式 
--- 

### 常用基本数据类型

#### `int`家族：
|类型|字节长度|数据范围（dec）|备注|
|---------------|:----:|:------------:|:-----:|
|`int`(标准整形)|4|-2147483648~+2147483647|无小数点最常用的数据类型|
|`unsigned`&nbsp;`int`(无符号整型)|4|0~+4294967295|
|`short`&nbsp;`int`（短整形）|2|-32768~+32767|
|`unsigned`&nbsp;`short`&nbsp;`int`(无符号短整型)|2|0~65535|
|`long` `int`(长整型)|4[^1]| -2147483648~+2147483647|
|`unsigned` `long` `int`(无符号长整型)|4|0~+4294967295|

*注意：指针的长度默认为`unsigned` `long`*
<br>

#### *浮点型* 家族
|类型|字节长度|数据范围&nbsp;（DEC）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|有效数字&nbsp;[^2]|
|---------------|:----:|:------------|:-----:|
|`float`(单精度浮点)|4|3.4x10^-38^~~3.4x10^38^|6~7|
|`double`(双精度浮点)|8|1.7x10^-308^~~1.7x10^308^|15~16|
|`long`&nbsp;`double`（长双精度浮点）|16|-1.2x10^-4932^~1.2x10^4932^|18~19|

***注意：无论最终怎么表示，浮点型在内存中永远是按科学计数法的指数形式储存的***
<br>

#### *字符型* 家族

|类型|字节长度|数据范围（dec）|备注|
|---------------|:----:|:------------:|:-----:|
|`char`(标准字符型)|1|-128~+127|数据范围是指此变量作为 *整数* 的时的数据范围|
|`unsigned`&nbsp;`char`(无符号字符型)|1|0~255|有无符号在变量表达字符时并没有区别，但表达整数时有区别（具体详见[`char`和 `unsigned` `char` 的区别浅析](#`char`和`unsignedchar`的区别浅析)）|

- 字符型与整数密切相关，因为它们在内部其实是被存储为整数。每个可打印的字符以及许多不可打印的字符都被分配一个唯一的数字。（ASCII码），~~btw，java中的`char`型是`unicode`~~
- 如果需要使用字符声明`char`型，则必须用`‘’`括起来，因为这里的字符常数就是赋给变量的值,如：
    ~~~C++
    char LETTER= 'A';
    ~~~
- 常见的ASCII码对应：`'0'＝48　　　　'A'＝65　　　　'a'＝97`
(**ASCII码值中，大小写字母码的关系是对应的大写字母与小写字母之间相差32，大写字母码<小写字母码**)
<br>
##### 字符常数和字符串常数的区别
~~~C++
cout << 'H' << endl;  //这显示的是字符常数
cout << "Hello" << endl; //这显示的是字符串常数
~~~
1. 字符常数使用`''`包裹，字符串常数用`“”`包裹。
2. 字符常数只占用一个字节，而字符串常数可占用无数多个字节
    - 因而，程序必须有一些方法知道它有多长。在 C++ 中，这是通过在其末尾附加一个额外的字节并将数字 0 存储在其中来完成的。这被称为 `null 终止符`或 `null 字符`，它标记着字符串的结尾，这同时也是ASCII码值为0的字符常数
    
        - 这也解释了为什么“abc”占4个字节而不是3
        <br>
3. 有些字符串虽然看起来像是只有一个字符，但实际上并不是。另外，也有一些字符看起来像是字符串，例如换行符` \n`，虽然它由两个字符表示，一个反斜杠和一个控制字符 n，但是它在内部其实只表示一个字符。事实上，所有的[转义序列](###C++的转义序列)在内部都只有 1 个字节。
### 运算符与表达式
##### 运算符的定义
运算符是一种告诉编译器执行特定的**数学**或**逻辑**操作的符号。
Cpp提供了以下运算符
- 算术运算符
- 关系运算符
- 杂项运算符
- 位运算符
- 赋值运算符
- 杂项运算符



~~~C++
 #include<iostream>   //后面笔记的AB变量都要如此
 using namespace std;
 int main()
 {
     int a,b,c;
     a=10,b=20;
 }
~~~
#### 算术运算符
|运算符|描述|实例|
|---|----|---|
|+|简单加法|A+B=31|
|-|简单减法|A-B=-10|
|\*|简单乘法|A*B=200|
|/|简单除法^\*^|A/B=**0**
|%|取模运算符，*整除后取余*|A%B=10|
|++|自增运算符，*整数值加一*|A++=11|
|--|自减运算符，*整数值减一*|A--=9|
\*:　除法运算后的结果和两个变量的数据类型息息相关，  
表格中的A,B是`int`所以结果是0*毕竟 `int`没有小数*  
但如果是`double`或者`float`的话，结果就是0.5了

#### 关系运算符
**注意**：在几乎所有的高级语言中，1表示真，0表示假
|运算符|描述|实例|
|:---:|----|---|
|==|检查是否相等，相等为真|（A==B）输出为0|
|!^*^=|检查是否不等，不等为真|（A!=B）输出为1|
|>|检查是否大于，大于为真|（A> B）输出为0|
|<|检查是否小于，小于为真|（A< B）输出为1|
|>=|多加了个等于|略|
|<=|多加了个等于条件|略|
\*：*几乎在所有的高级语言中，`!`在表示关系时都表示“非”的意思*
#### 逻辑运算符
|运算符|描述|实例|
|:---:|----|---|
|`&&`|`逻辑与运算符`,如果两个操作数都非零，则条件为真|A&&B→0|
|`||`|`逻辑或运算符`，如果两个操作数中有任意一个非零，则条件为真|略|
|`!`|`逻辑非运算符`,用来*逆转* 操作数的逻辑状态。如果条件为真则逻辑非运算符将使其为假||
#### 位运算符
>通俗来讲，*位运算符就是二进制的算术运算符*，所谓**按位运算**就是指先将数字转化成二进制数字，然后按照二进制的规则进行相关的运算。
##### 位运算符详细解释

`&`（按位与 *AND*）: 按位与运算符：参与运算的两个值,如果两个相应位都为1,则该位的结果为1,否则为0
例如:   
```C
        0 0 1 1 1 0 1 1
        1 0 1 1 0 1 0 1
     --------------------
        0 0 1 1 0 0 0 1
```
`|` （按位或 OR）: 按位或运算符：只要对应的二个二进位有一个为1时，结果位就为1。
例如:  
```C
        0 1 0 1 0 0 1 1
        1 0 0 1 1 0 0 1
      -------------------
        1 1 0 1 1 0 1 1
```
`~`（按位非）: 按位取反运算符：对数据的每个二进制位取反,即把1变为0,把0变为1
例如:  
```C
        1 1 0 0 1 0 1 0
      ------------------
        0 0 1 1 0 1 0 1
```
`^`（按位异或）: 按位异或运算符：当两对应的二进位相异时，结果为1
例如: 
``` C
        0 0 1 1 0 1 0 1
        0 1 0 1 0 1 0 0
      ------------------
        0 1 1 0 0 0 0 1
```
`<< `(有符号左移位) : 左移动运算符：运算数的各二进位全部左移若干位，由"<<"右边的数指定移动的位数，高位丢弃，低位补0。
例如:  
```C
<< 1    print(6 << 1) # 6 * 2**1
        0 0 1 0 1 0 1 1 
      ------------------
        0 1 0 1 0 1 1 0
```
`>>`（有符号右移位）: 右移动运算符：把">>"左边的运算数的各二进位全部右移若干位，">>"右边的数指定移动的位数，低位丢弃，高位补0
例如:
```C
  >> 1  print(6 >> 1) # 6 // 2**1
        0 1 0 1 0 1 0 1
      ------------------
        0 0 1 0 1 0 1 0
```
##### 位运算符的特点
1. 效率高，内存消耗少 *在老旧的电脑上位运算符效率会大大地大于加减法，但是经过intel的~~挤牙膏~~改进，现在已然和正常整形数据的加减法差别不大了，但还是要大幅度快于乘法除法*
<br>
2. 在某些情况中，位操作可以避免或者减少在一个数据结构上需要进行循环的次数，并且可以成倍的效率提升，
因为位操作是并行处理的。但是位操作的代码比较难以编写和维护。
<br>
3. 唯一的二进制运算符

#### 赋值运算符
|运算符|描述|实例|
|:---:|----|---|
|=|右值赋给左值，最基本的赋值运算符|`A=B`相当于把B值赋给A|
|+=|加且赋值运算符 把右边操作数加上左边操作数的结果赋值给左边操作数|`B+=A`==`B=B+A`|
|-=|减且赋值运算符 把右边操作数减去左边操作数的结果赋值给左边操作数|`B-=A`==`B=B-A`|
|*=|乘且赋值运算符 把右边操作数乘与左边操作数的结果赋值给左边操作数|`B*=A`==`B=B*A`|
|/=|除且赋值运算符，把右边操作数除左边操作数的结果赋值给左边操作数|`B/=A`==`B=B/A`|
|%=|略|略|
|&=|按位与并且赋值|`B&=A`==`B=B&A`|
|^=|略|略|
|\|=|略|略|
|>>=|略|略|
|<<=|略|略|

####　杂项运算符
- 不属于逻辑与算术的任何一类，但任然具有重要功能的运算符
    - 以下是C艹支持的杂项运算符

|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;运算符&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|描述|实例|
|:---:|---|---|
|`sizeof()`|`返回变量的大小运算符`。例如sizeof(a) 将返回 4，其中 a 是整形|sizeof(int)→4|
|`Condition ?X:Y`|`条件运算符`,如果 Condition 为真 ? 则值为 X : 否则值为 Y（？）|c = (a + b == 10) ? a : b;，→c=20|
|`,`|`逗号运算符`会顺序执行一系列运算 整个逗号表达式的值是以逗号分隔的列表中的最后一个表达式的值|`a,b`|
|`.(英文句号的店)`AND`->（箭头）`|成员运算符用于引用类、结构和共用体的成员（？）|（？）|
|cast|`强制转换运算符`，把一种数据类型转换为另一种数据类型。例如，int(2.2000) 将返回 2。|(?)|
|`&`(放在变量前)|`取址运算符`,返回变量的地址，将给出变量的实际地址|&a=0x…………|
|`*`(用在基本数据类型前)|`指针运算符` * 指向一个变量。例如，*var; 将指向变量 var|
|`*`(用在指针类型前)|`取内容运算符` 返回指针所指变量的内容，将给出该所指的实际内容|

#### 运算符的优先级
> 括号>单目>算术>关系>位>逻辑>条件>赋值>逗号

|类别|	运算符|	结合性|
|----|----|----|
|后缀|	() [] -> . ++ - -	|从左到右|
|一元|	+ - ! ~ ++ - - (type)* & sizeof	|从右到左|
|乘除|	* / %	|从左到右|
|加减|	+ -	|从左到右|
|移位|	<< >>	|从左到右|
|关系|	< <= > >=	|从左到右|
|相等|	== !=	|从左到右|
|位与AND|	&	|从左到右|
|位异或OR|	^	|从左到右|
|位或OR|	\||从左到右|
|逻辑与AND|	&&|	从左到右|
|逻辑或OR|	\|\||	从左到右|
|条件|	?:	|从右到左|
|赋值|	= += -= *= /= %=>>= <<= &= ^= \|=	|从右到左|
|逗号|	,	|从左到右|

### 表达式
在程序中，运算符是用来操作数据的，这些数据也被称为`操作数`，使用运算符将操作数连接而成的式子称为：`表达式`
表达式具有如下特点:

- 常量和变量都是表达式
- 运算符的类型对应表达式的类型
- 每一个表达式都有自己的值



## 附录
---
### C++的转义序列
|表现形式|意义|
|--|----| 
|\n|换行符|
|\r       |回车符|
|\t        |水平制表符（Tab键）|
|\b      |退格符（BackSpace键）|   
|\\\       |反斜线|
|\'       |单引号|
|\"       |双引号|
|\0     | 空字符|
|\a|响铃|

### `char`和`unsigned　char`的区别浅析
- **相同点**：在内存中都是一个字节，8位（2^8^=256），都能表示256个数字
- **不同点**：char的最高位为符号位，因此char能表示的数据范围是-128~127，  unsigned char没有符号位，因此能表示的数据范围是0~255

> **实际使用**中，如普通的赋值，读写文件和网络字节流都没有区别，不管最高位是什么，最终的读取结果都一样，在屏幕上面的显示可能不一样。

>但是要把一个char类型的变量赋值给int、long等数据类型或进行类似的**强制类型转换时**，系统会进行类型扩展，这时区别就大了。对于char类型的变量，系统会认为最高位为符号位，然后对最高位进行扩展，即符号扩展。若最高位为1，则扩展到int时高位都以1填充。对于unsigned char类型的变量，系统会直接进行无符号扩展，即0扩展。扩展的高位都以0填充。所以在进行类似的操作时，如果char和unsigned char最高位都是0，则结果是一样的，若char最高位为1，则结果会大相径庭。

*更详细的证明只能见我的收藏夹了*~~程序读不懂啊哼哼哼啊啊啊啊啊~~
[^1]:>int的字节长度，是由硬件和系统共同决定的。 <br> 
dos是运行在16位CPU下的，他的int就是两个字节  <br>
win95是运行在32位CPU下的，但win95还是16位的系统设计，所以他的int还是2个字节  <br>
NT，XP,cpu是32位的，windows也支持32位，所以他的int就是32位的了。语言并没有规定类型的长度  <br>
但是有一些规则，比如：char不论在什么时候都是一个字节（即8个bit）  <br>
int永远比char长，long不会小于int的长度。

[^2]:>有效数字：**浮点型数据的精度 <br>**
float和double的精度是由尾数的位数来决定的。<br>
浮点数在内存中是按科学计数法来存储的，其整数部分始终是一个隐含着的“1”，由于它是不变的，故不能对精度造成影响。<br>
float：2^23 = 8388608，一共七位，这意味着最多能有7位有效数字，但绝对能保证的为6位，<br>
也即float的精度为6~7位有效数字；double：2^52 = 4503599627370496，一共16位，同理，double的精度为15~16位。









