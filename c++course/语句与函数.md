## 语句
#### 语句的基本概念
- **C++程序中最小的独立单位是语句(statement)**。它相当于一篇文章中的一个句子。句子是用句号结束的。语句一般是用分号结束的(**复合语句**是以右花括号结束的)
- 而C++程序应该包括数据描述(由*声明语句* 来实现)和数据操作(由*执行语句* 来实现)。数据描述主要包括数据类型的声明、函数和变量的定义、变量的初始化等。数据操作的任务是对已提供的数据进行加工

因此，C++的语句可分为四个种类
|语句名称|简答解释|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;实例&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|
|---|---|---|
|<span id="jump1">声明语句</spn>|将变量名标识符的有关信息告诉编译器，使编译器**“认识”**该标识符,可以是变量，函数，类，种种形式|`int a;`,`int main();`,类还没学，摸了|
|执行语句|通知计算机完成一定的操作，可以细分为`控制语句` `函数语句` `流对象调用语句` `表达式语句`,C中大部分语句都是表达式语句|```for(); max(x,y,z); cout<<a; a+=b``` |
|空语句|即只有一个分号的语句，它什么也不做。有时用来做被转向点，或循环语句中的循环体|;|
|复合语句|可以用 { }把一些语句括起来成为复合语句|{a=b;b=c;c=a}
- 声明语句，空语句，复合语句已经在表里讲清楚了，下文着重讲解各种执行语句的用法

### 控制语句
#### 1.判断语句
**if与if…else结构**
`if`结构（不带大括号）
```c
if(条件)
  表达式1; //如果条件为真，则会执行这一句，如果条件为0则不会执行，**if的就近原则**
  表达式2; //无论上面的条件是真是假，永远都会执行下面这两句
  表达式3;
```
`if else` 结构
- 基本
```c
if(表达式)
{为!0就执行这一段}
else
{为0就执行这一段}
```
- 各种变体
```c
  //if...else if结构
   if（表达式1）
   {语句1；}  //如果表达式1条件为真，则会执行这一句，如果为假则不执行

    Else if（表达式2）  //在第一行表达式1值为0的时候才会进行表达式2的判断
    {语句2;}  //如果表达式2条件为真，则会执行这一句，如果为假则不执行

    //后面也可以无限套娃，不赘述
```
```c
 //if语句的嵌套
  if( )
        if( )语句1
        else 语句2  //重点：else总是与它上面最近的、且未配对的if配对
    else
        if( )语句3
        else 语句4
  ```
  **`switch`语句**
  ```c
  //switch语句的基本语法
  switch(expression){
    case constant-expression  :
       statement(s);
       break; // 可选的
    case constant-expression  :
       statement(s);
       break; // 可选的
  
    // 您可以有任意数量的 case 语句
    default : // 可选的
       statement(s);
}
```
- `switch` 语句中的 `expression` 必须是一个整型或枚举类型，或者是一个`class`类型，其中`class`有一个单一的转换函数将其转换为整型或枚举类型。
<br>
- 在一个 `switch` 中可以有任意数量的 `case` 语句。每个 `case` 后跟一个要比较的值和一个冒号。
<br>
- `case` 的 `constant-expression` 必须与 `switch` 中的变量具有相同的数据类型，且必须是一个常量或字面量。
<br>
- 当被测试的变量等于 `case` 中的常量时，`case` 后跟的语句将被执行，直到遇到 `break` 语句为止。
<br>
- 当遇到 `break` 语句时，`switch` 终止，控制流将跳转到 `switch` 语句后的下一行。
<br>
- 不是每一个 `case` 都需要包含 `break`。如果 `case` 语句不包含 `break`，控制流将会 继续 后续的 `case`，直到遇到 `break` 为止。
<br>
- 一个 `switch` 语句可以有一个可选的 `default` `case`，出现在 `switch` 的结尾。`default` `case` 可用于在上面所有 `case` 都不为真时执行一个任务。`default` `case` 中的 `break` 语句不是必需的。

**示例**
```c
#include <iostream>
using namespace std;
 
int main ()
{
   // 局部变量声明
   char grade = 'D';
 
   switch(grade)
   {
   case 'A' :
      cout << "很棒！" << endl; 
      break;
   case 'B' :
   case 'C' :
      cout << "做得好" << endl;
      break;
   case 'D' :
      cout << "您通过了" << endl;
      break;
   case 'F' :
      cout << "最好再试一下" << endl;
      break;
   default :
      cout << "无效的成绩" << endl;
   }
   cout << "您的成绩是 " << grade << endl;
 
   return 0;
}
```
当上面的代码被编译和执行时，它会产生下列结果：
```
您通过了
您的成绩是 D
```



#### 2.循环语句
  **`while()~`语句**
  ```c
  //while语句在C++中的基本语法
  while(condition)
{
   statement(s);
}
  ```
  - 解释：
  1. statement(s) 可以是一个单独的语句，也可以是几个语句组成的代码块。condition 可以是任意的表达式，当为**任意非零值时都为真**。当条件为真时执行循环。
  <br>
  2. 当条件为假时，程序流将继续执行紧接着循环的下一条语句，**因此**，*while 循环的关键点是循环可能一次都不会执行。当条件被测试且结果为假时，会跳过循环主体，直接执行紧接着 while 循环的下一条语句*

  **`do while()~`语句**
   ```c
  //do while语句在C++中的基本语法
  do
{
   statement(s);

}while( condition );
  ```
  - 解释
  1. 原理：如果条件为真，控制流会跳转回上面的 `do`，然后重新执行循环中的 `statement(s)`。这个过程会不断重复，直到给定条件变为假为止
2. 与单纯的`while`最大的不同是，条件表达式出现在循环的尾部，所以循环中的 `statement(s)` 会在条件被测试之前至少执行一次

  **`for()~`语句**
  ```c
  //for语句在C++中的基本语法
  for ( init; condition; increment )
{
   statement(s);
}
 ```
- 解释：
1. `init`会首先被执行，且只会执行一次。这一步允许您*声明* 并初始化任何循环控制变量。也可以不在这里写任何语句，只要有一个分号出现即可。

2. 接下来，会判断 `condition`。如果为**真**，则执行循环主体（*直接进入循环体，无视`increment`）。如果为假，则不执行循环主体，且控制流会跳转到紧接着 for 循环的下一条语句

3. 在执行完 `for`循环主体后，控制流会跳回上面的 `increment` 语句。该语句允许您更新循环控制变量。该语句可以留空，只要在条件后有一个分号出现即可

4. 条件再次被判断。如果为**真**，则执行循环，这个过程会不断重复（循环主体，然后增加步值，再然后重新判断条件）。在条件变为**假**时，for 循环终止。

**嵌套循环**
- 可以在任何类型的循环内嵌套其他任何类型的循环。比如，一个 `for` 循环可以嵌套在一个 `while` 循环内，反之亦然

~~还是看实例一点一点尝试读代码比较容易理解些~~

```c++
  //下面的程序使用了一个嵌套的 for 循环来查找 2 到 100 中的质数：
#include <iostream>
using namespace std;
int main ()
{
    int i, j;
    for(i=2; i<100; i++) {
        for(j=2; j <= (i/j); j++) { 
            if(!(i%j)) {  //`!`相当于逆转，i%j的值为0时反而会相当于是真
                break;    //如果找到，则不是质数，break表示跳出循环执行下一语句
            }
        }
        if(j > (i/j)) {   //
            cout << i << " 是质数\n";
        }
    }
    return 0;
}
```
#### 3. 循环控制语句
**`break`语句**

```c
//基本语法
break;
```
- 定义上，`break`语句终止 `loop`（循环语句的统称） 或 `switch` 语句，程序流将继续执行紧接着 `loop` 或 `switch` 的下一条语句
  - 当 break 语句出现在一个循环内时，循环会立即终止，且程序流将继续执行紧接着循环的下一条语句
  - 它可用于终止`switch`语句中的一个`case`
- 当`break`出现在嵌套循环中，`break`则会终止最内层的循环，从而执行该块之后的下一行代码

**`continue`语句**
```c
//基本语法
continue;
```
- `continue`会强制终止当前正在进行的循环代码，并强迫开始下一次的循环
- 对于`for`循环，其导致执行条件测试和循环增量部分，对于`while`循环，会导致程序控制回到条件测试上

**goto语句**
```c
//基本语法
goto label;
..
.
label: statement;   //label 是识别被标记语句的标识符,可以是任何除 C++ 关键字以外的纯文本。(也就是说不一定非得用label这个词，你也可以用loop，sunxiaochuan等等)
                    //标记语句可以是任何语句，放置在标识符和冒号（:）后边。


```
- `goto`语句允许把控制**无条件**转移到同一函数内的被标记的语句
  - 注意：在任何编程语言中，都不建议使用`goto`语句。因为它使得程序的控制流难以跟踪，使程序难以理解和难以修改。任何使用`goto`语句的程序可以改写成不需要使用`goto`语句的写法
    - 但存在即合理,`goto`语句也一个很好的作用是退出深嵌套例程（比如一堆for的嵌套），因为`break`只会使程序退出**最内层**循环





## 函数
**基本**
- 函数是*一组一起执行一个任务的语句*。每个 C++ 程序都至少有一个函数，即主函数 `main()`(由操作系统所调用[?]) ，所有简单的程序都可以**定义其他额外的函数。
- 而函数在一段程序里可以随意的被**定义**，被**声明**，何为定义函数和声明函数，后文会详细提到
- C++ 标准库提供了大量的程序可以调用的*内置函数*。例如，函数 `strcat()` 用来连接两个字符串，函数 `memcpy()` 用来复制内存到另一个位置
- 函数还有很多的叫法，比如方法，子程序等等，不一一赘述

### 函数的定义
C++ 中的函数定义的一般形式如下：
```c++
return_type function_name( parameter list )  //返回值类型   函数名   （参数）
//上行皆为函数头
{
   body of the function //函数体
}
```
简单解释：
 - **返回类型（return_type）**:一个函数可以返回一个值。return_type 是函数返回的值的数据类型。有些函数执行所需的操作而不返回值，在这种情况下，return_type 是关键字 void
 - **函数名称（function_name）**：这是函数的实际名称。函数名和参数列表一起构成了**函数签名**
 - **参数（parameter list）**：参数就像是占位符。当函数被调用时，您向参数传递一个值，这个值被称为**实际参数** *所以也一样存在“形式参数”后面也会详细解释*。参数列表包括函数参数的类型、顺序、数量。参数是可选的，也就是说，函数可能不包含参数。（）
 - **函数主体（body of the function）**:函数主体包含一组定义函数执行任务的**语句**
 #### 函数的返回

 函数的返回值是指函数被调用之后，执行函数体中的代码所得到的结果，这个结果通过`return`语句返回

> 所谓函数返回值是一个函数在运算结束以后向调用它的母函数或者系统反馈一个值,这个值可以是各种变量类型,
**返回值可以理解为解决一个问题以后得到的结论，把这个结论交给别人，就像写在书上成为一个定理，来让别人使用。**

例子：
```c
//此实例为C语言编写
int add(int a,int b)
{
    return (a+b);
}
int main()
{
    int res;
    res=add(3,4);
    printf("%d",res);
    return 0;
}
```
- 在主函数main中调用子函数add,并传递参数3和4过去，add经过运算后得到值7，通过return语句将得到的值返回给调用它的main函数供其使用，而在main中，返回值被用于给res赋值。

 *注意：函数的返回是一个非常复杂难以解释的过程，而且还涉及到指针引用栈清理等等我还没精通的知识，所以此处就做一个初步的了解，等以后我学到足够多了再来慢慢补充*

 **`return`语句的一般用法为：**
 ```c
 return 表达式;
 //or
 return (表达式);
 //括不括号无所谓的
 ```
 **作用：**
 - 返回函数值
 - 不再执行后续语句，程序控制返回调用点
 - 一个函数体内可以有多个return 语句
 - 表达式 返回值的类型与函数类型不相同时，
   自动强制转换成**函数的类型**

**`main()`函数（主函数）的返回值：**
无论 C / C++，从 main 函数返回的效果都相当于调用 exit 函数，main 的返回值会作为传给 exit 函数的参数

而exit 对于参数的说明是这样的：
- 如果参数为0或者 EXIT_SUCCESS，向外部报告程序运行以圆满结束
- 如果参数为 EXIT_FAILURE, 向外部报告程序运行以失败告终
- 如果参数为其他值，效果由实现定义

所以，return 0 是有确定语义的返回方式；而 return 1 则**不具备有可移植性**

**无返回值函数（返回`void`）**
没有返回值的`return`语句只能用在返回类型是`void`的函数中，这类函数在最后一句后面会隐式执行`return`语句，**一个返回类型是`void`的函数也能使用`return`语句**，不过此时这个表达式必须是*另一个返回 void 的函数。*
```c
#include<iostream>
void func1(int value)
{
	std::cout << value << std::endl;
}

void func2(int value)
{
	return func1(value);
}


int main(void)
{
	func2(100);
	system("pause");
	return 0;
}
//输出结果为100，void也可以互相返回，但return还是没有**值**
```
返回对象
返回指针
返回引用
[^_^]: # (兄弟先整些简单的再来搞这些）
---
#### 函数的声明
和**声明变量**一样，函数的声明一样是靠着[声明语句](#jump1)来实现的，函数的主体可以在**任意的地方再进行单独的定义**
函数声明包括以下几个部分：

```c
creturn_type function_name(parameter list);   //注意分号
```
针对上面定义的函数` max()`，以下是函数声明：

```c
int max(int num1, int num2);
```
在函数声明中，参数的名称并不重要，**只有参数的类型是必需的**，因此下面也是有效的声明：
```c
int max(int, int);
```
**当您在一个源文件中定义函数且在另一个文件中调用函数时，或者调用的函数的定义还在后几行时**，函数声明是必需的。在这种情况下，您应该在调用函数的文件顶部声明函数。

---

#### 函数的调用
函数的调用语法：
```c
function_name(parameter list)
```
- 单独把函数的调用写出来一般都构不成一个语句（当然你想的话也可以加个分号就是了一般确实没有什么意义就是了），一般都会配合表达式来使用
<br>
- 当程序调用函数时，程序控制权会转移给被调用的函数。被调用的函数执行已定义的任务，当函数的返回语句被执行时，或到达函数的结束括号时，会把程序控制权交还给主程序。
- 调用函数时，传递所需参数，如果函数返回一个值，则可以存储返回值
---

#### 函数参数
- 如果函数要使用参数，则必须声明所接受的参数值的变量。这些变量称为函数的**形式参数**。
- 形式参数就像函数内的其他[局部变量](#jump2)，在进入函数时被创建，退出函数时被**销毁**

当调用函数时，有三种向函数传递参数的方式：
|调用类型|描述|
|--|-----|
|传值调用|	该方法把参数的实际值赋值给函数的形式参数。在这种情况下，修改函数内的形式参数对实际参数没有影响。|
|指针调用|	该方法把参数的地址赋值给形式参数。在函数内，该地址用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。|
|引用调用|	该方法把参数的引用赋值给形式参数。在函数内，该引用用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。|
俺先去学习玩指针引用以及变量类型再回来理解一下


##### 函数的嵌套调用
#### 2021年4月28日14:43:29课堂随记
栈
入栈：从下往上堆盘子，出栈：从上往下取盘子，盘子替换成function那就是函数的入栈和出栈 *函数栈*
递归调用：function自己调用自己，同样遵守函数栈的规律，
由于函数栈的性质，所以实际上非递归的内存消耗非常大，所以优化上会尽量避免递归的使用，但实际上递归很多时候也无法避免（数学表达式，斐裂玻切数列等等问题）。
非递归：
函数的指针，就如同变量可以被申明为指针，函数作为一个可以被声明的对象也有他的入口地址，同样地也有相应的函数指针，函数的指针与变量的指针非常的类似

但其实还是有很大的区别！比如地址运算符，&*等等只要不带小括号都能够表示地址，但是只要加了小括号，永远都是表示他的`值`


**函数的类型**：当一个函数的返回值和形参的数据类型都一模一样，（比方说都是`double`），那他们就可以被称之为是同一个类型的函数
可以被继续定义为`typedef double  functionType  ( double, double) ;`

**内联函数**
- 目的是降低频繁调用子程序的时间开销
- 原理有点类似于变量的引用，声明后调用时替换成内联函数，省去了出栈入栈的累赘

**函数重载**：
- 简单点说就是你可以定义很多个*同名*的函数，但是他们定义的形参要么变量个数不同，要么数据类型不同，所以真的调用吼也可以很快的区分出来。
- 但还是要记住返回值的数据类型是万万不可动的，动了不加重载叫重写了

>C++ 中每个变量都有指定的类型，类型决定了变量存储的大小和布局，该范围内的值都可以存储在内存中，运算符可应用于变量上








**标识符**
堆区：编码人员声明的，
**储存特性**
堆区：常容易产生内存碎片导致其冗余~~所以java天下第一~~
栈区：函数中的参数和局部变量，自动存储（auto）类型，都放在栈区里
*自动存储类型*
没初始化那就是个随机数
**静态存储类**`static`*加了就是全局区的人了*，//只是另外一个小类罢了
和全局变量区息息相关，
1. 如果没有初始化，自动初始化为0
2. 只初始化一次
3. 记忆功能
4. 没初始化就是0


实际上运行代码也是还要开辟栈的空间的，但是代码确实还是放在代码去的

函数形参的函数原型形式参数表中的标识符具有函数原型`作用域`
**作用域**
文件作用域： 
这种是每个函数都有的
文件作用于的声明（externed）

`全局变量`和`局部变量`
具有文件作用域的变量（函数外声明的变量）→全局变量
在函数或一个代码块内部声明的变量→局部变量
局部变量和全局变量的名称可以相同，但是在函数内，局部变量的值会**覆盖**全局变量的值

#### 编译器工作原理和预编译
（解决方案.clc）
头文件*声明与常量* 与源文件*算法与执行* 的互相调用
**C++编译器的工作过程**

预处理→`#`开头的代码,(object)
`#include`，就是一种预处理，<iostream>这里面搜的是固定系统库，""这个是优先搜工作目录（同一个项目）的，而且可以添加路径去搜索

```c
//条件编译
#if conditions
programs
#endif
```
不满足conditions就不编译programs嗷

**宏定义指令**
```c
#ifndef SB_H
  #defineSB_H
  BALABALABLA
#endif
```
**终止程序运行**









