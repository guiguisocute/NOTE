## 值与变量
首先要明确一个概念，值（value）与变量（variable）并不是同一个东西
- 值只有 **类别(category)** 的划分，变量只有 **类型(type)** 的划分。
- 值不一定拥有 **身份(identity)**，也不一定拥有**变量名**（例如 表达式中间结果 `i + j + k`)
### C++ 中的左值（Lvalues）和右值（Rvalues）
C++ 中有两种类型的表达式：

- **左值（lvalue）**：顾名思义，一般情况下常出现在**赋值符号左边的值**.指向内存位置的**表达式**被称为左值（lvalue）表达式。因此左值可以出现在赋值号的左边或右边。准确来说，左值是表达式后依然存在的持久对象
<br>
  - lvalue是我们要赋值的对象。它是一个变量，存在于内存中，它的值可以被改变，**可以被取地址**。任何可以通过它的名字，指针或者引用来接触的变量都是lvalue，例如定义的某个变量和函数的参数， 对一个表达式取地址。
<br>
- **右值（rvalue）**：与左值对应，右边的值，表达式结束后就不再存在的临时对象。指的是存储在内存中某些地址的**数值** 。右值是不能对其进行赋值的表达式，也就是说，右值可以出现在赋值号的右边，但不能出现在赋值号的左边。
<br>
  - rvalue则是一个临时变量，不存在于内存中，存在于CPU的寄存器或者指令的立即数中(immediate number)，因此我们不能改变它的值，**不能取地址**。它们通常是一个直接的数值，运算符返回的数值，**或是函数的返回值**，或者通过隐式类型转换得到的对象
<br>

- **纯右值（prvalue）**： 纯粹的右值，要么是纯粹的字面量，例如` 10, true(布尔型常量)`; 要么是求值结果相当于字面量或匿名临时对象，例如 `1+2`。非引用返回的临时变量、运算表达式产生的临时变量、原始字面量、Lambda 表达式都属于纯右值。

变量是左值，因此可以出现在赋值号的左边。数值型的字面值是右值，因此不能被赋值，不能出现在赋值号的左边。
*后面属实有点过于深奥了，先收藏先*

### 存储特性
#### 变量作用域
作用域是程序的一个区域，一般来说有三个地方可以定义变量：

- 在函数或一个代码块内部声明的变量，称为**局部变量**。

- 在函数参数的定义中声明的变量，称为**形式参数**。*详见函数笔记*

- 在所有函数外部声明的变量，称为**全局变量**。

#### 全局变量
总而言之先知道它是在函数外定义的
#### 局部变量
总而言之先知道他是在代码块被定义的，只用于函数本身

静态全局变量
静态局部变量……
#### 程序的内存分配
一个由c/C++编译的程序占用的内存分为以下几个部分:
|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;名称&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|解释|
|---|----|
|栈区（stack）| 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。|
|堆区（heap） | 一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收 。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表|
|全局区（静态区）（static）|全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。 - 程序结束后有系统释放|
|文字常量区|常量字符串就是放在这里的。 程序结束后由系统释放|
|程序代码区|存放函数体的二进制代码。|
**example：** 
```c
#include<iostream>
using namespace std;
int a = 0;			//全局初始化区
char *p1;				//全局未初始化区
main()
{
	int b;			//整形变量，栈
	char s[] = "abc";		//数组，栈
	char *p2;			//栈
	char *p3 = "123456";	//123456\0在常量区，p3在栈上。
	static int c =0;		//全局（静态）初始化区
	p1 = (char *)malloc(10);
	p2 = (char *)malloc(20);	//分配得来得10和20字节的区域就在堆区。
	strcpy(p1,"123456");	//123456\0放在常量区，编译器可能会将它与p3所指向的"123456"优化成一个地方
}
```




---
#### 2021年4月28日14:43:29课堂随记




>C++ 中每个变量都有指定的类型，类型决定了变量存储的大小和布局，该范围内的值都可以存储在内存中，运算符可应用于变量上








**标识符**
堆区：编码人员声明的

**储存特性**
堆区：常容易产生内存碎片导致其冗余~~所以java天下第一~~
栈区：函数中的参数和局部变量，自动存储（auto）类型，都放在栈区里
*自动存储类型*
没初始化那就是个随机数
**静态存储类**`static`*加了就是全局区的人了*，//只是另外一个小类罢了
和全局变量区息息相关，
1. 如果没有初始化，自动初始化为0
2. 只初始化一次
3. 记忆功能
4. 没初始化就是0


实际上运行代码也是还要开辟栈的空间的，但是代码确实还是放在代码去的

函数形参的函数原型形式参数表中的标识符具有函数原型`作用域`
**作用域**
文件作用域： 
这种是每个函数都有的
文件作用于的声明（externed）

`全局变量`和`局部变量`
具有文件作用域的变量（函数外声明的变量）→全局变量
在函数或一个代码块内部声明的变量→局部变量
局部变量和全局变量的名称可以相同，但是在函数内，局部变量的值会**覆盖**全局变量的值

#### 编译器工作原理和预编译
（解决方案.clc）
头文件：*声明与常量* 与源文件：*算法与执行* 的互相调用
**C++编译器的工作过程**

预处理→`#`开头的代码,(object)
`#include`，就是一种预处理，<iostream>这里面搜的是固定系统库，""这个是优先搜工作目录（同一个项目）的，而且可以添加路径去搜索

```c
//条件编译
#if conditions
programs
#endif
```
不满足conditions就不编译programs嗷

**宏定义指令**
```c
#ifndef SB_H
  #defineSB_H
  BALABALABLA
#endif
```
**终止程序运行**


