# 数据

**DEF：**
计算机中表现的图片，文字，视频，知识，各种工程文件，都算数据，他们都有以下特征：
- 可以输入到计算机中
- 能被计算机处理（可以简单的理解为比特化？）
如整形浮点型这样有“实体”的数可以进行数值计算，字符类型的数据类型就要进行非数值的处理（？），但是其他形式如声音、图像等都是可以通过编码的手段**转换**陈字符数据。

### 数据元素
**DEF：** 是组成数据的，有一定意义的基本单位，在计算机中通常作为**整体**处理，也被称为**记录**
- 例子就是在学校里数据元素就是老师和学生，在牛马里数据元素就是一个一个具体的打工人

#### 数据项
组成数据源元素的一个 ！**数据不可分割的最小单位** ！，但一般讨论问题的时候都只讨论数据元素，毕竟数据元素才是建立数据模型的着眼点。

### 数据对象
性质相同（两者数据元素具有相同类型和数量的 **数据项**）的 **数据元素** 的集合，是数据的 *子集* 

### 数据结构
（操你妈前面铺垫了一大堆终于说重点了），其实就是想表达，数据元素之间，尽管他们会有一堆数据项，比如说一个链表的节点就有数据和next的地址的两个信息，有些更复杂的体系中有的数据元素有的元素还不太一样，但是呢，他们之间就像化学分子一样，原子间会有像 **“化学键”** 这样的东西把他们给**联系** 起来 ***数据结构，就是充当了这个化学键的成分，描述了 【数据元素 之间】的内在联系***

### 逻辑结构和物理结构
> 物理结构是数据的物质躯体，而逻辑结构是数据的灵魂蓝图。
>                                       ————deepseek R1

就像你看化学键结构有的人看极性（化学上），有的人看分子间的作用力（物理上），计算机中的 **联系** 也分 **逻辑视角** 与 **物理视角**
#### 逻辑结构(有点像建筑学)
- **集合结构**： 大家除了都是在赤石以外，没有什么其它的关系（比如江西师大二食堂一楼吃饭的同学们）
- **线性结构**： 互相之间是一对一的关系，我👁️你你👁️我，而且是 **非常非常严格的首尾相连**，就像火车车厢一样每一个车厢只有前后两个**节点**
- **树形结构**： 树形结构中的数据元素之间存在一种一对多的层次关系。：反正看图就完事了
<img src="https://guiguisocute-1318017707.cos.ap-guangzhou.myqcloud.com/202503152246910.png"/>

- **图形结构**： 图形结构数据元素是多对多的关系，也是看图就完事了，一看就能明白其中的差别
<img src="https://guiguisocute-1318017707.cos.ap-guangzhou.myqcloud.com/202503152251615.png"/>
> **通过上面的描述我们也可以看出**
> 逻辑结构是针对具体问题的，是为了解决某个问题，在对问题理解的基础上，选择一个合适的数据结构表示数据元素之间的逻辑关系。

#### 物理结构（有点像土木）
> 研究数据的**逻辑结构**在计算机中的存储形式。

- **顺序存储**：数据完全一个挨着一个紧凑排列在内存空间内，这个我已经理解了就不细讲了
- **链式存储结构**： 数据元素散乱分布在所有的内存空间中，存储关系不能反映出逻辑关系，有点像藏宝图那样，每个藏宝点留下下个地点的坐标，只能一个一个去找线索，而且中途可以插入新线索去改变路径
- **索引存储结构**：建立索引表加速定位，就像**图书馆**那样，目录卡片记录书名+书架坐标，先通过目录卡片找到这个区域了，然后再到对应区域去细查
- **散列存储结构**：直接飚定义什么哈希值可能不太好理解，就直接上游乐园储物柜的例子吧：
  游乐园存包处的哈希表
  - 根据门票号（哈希值）分配固定柜子 【分配的过程就是哈希函数的作用哈希函数本质上是个「数字炼金术」】
  - 不同游客可能被分配到同一柜子（哈希冲突）
  - 管理员用备用钥匙（再哈希）解决冲突

### （很重要）抽象数据类型（ADT）
> 抽象不是模糊，而是精确的逻辑约束

数据类型算是一种具象化的认知，多大的数据分配多大的 **“房间”** （黄箐我的知识没有还给你呢），但是ADT，则是把所有房间之间能够互相怎么进行操作的一种 **严格的定义**，因此他需要阐述数据元素的范围，联系，以及最重要的：**该如何对他们操作进行描述**

- 例如一个咖啡机的ADT定义
```python
class CoffeeMachineADT:
    # 状态控制
    def power_on() -> None:           """开机"""
    def power_off() -> None:          """关机"""
    
    # 咖啡制作
    def select_coffee_type(type: str) -> None:    """选择咖啡类型"""
    def brew_coffee() -> Coffee:       """制作咖啡"""
    
    # 资源管理
    def add_water(volume: int) -> None:           """加水"""
    def add_beans(weight: int) -> None:           """加咖啡豆"""
    def clean_waste_box() -> None:     """清理废料盒"""
    
    # 状态查询
    def get_status() -> dict:          """返回所有状态信息"""
 ```
 于是，我们很得到了一个咖啡机能够实现的接口，但不去考虑他具体的电路实现，这就是我们学习数据结构讨论的第一点：
 - 在数学与逻辑视图层面上去构建
  
很明显，在现在的科技中，电路和机械上去实现这些功能也不算很难的事，那么这些稍微具体的方法就是我们数据结构要学的第二点
- 去实现这些逻辑具体要做什么操作
  
然后，我们资源有限，资金有限，所以我们要考虑到成本，效率，这就是我们学习数据结构的第三点：
- 具体操作的花费（计算机里主要是在时间上面）
后面当然，不去会接线安装部件只在纸上谈兵毫无意义，所以最后我们也会学到最后一点
- 手把手的教你接线和安装机械部件（用高级语言去实现那些操作）。

# 算法
> 可以解决问题的有穷，确定，可行步骤的描述

时间问题我们直接看算法效率吧，具体算法是什么计算机导论也有讲过就不提了
## 时间复杂度计算
**大O记法**（此处与某个T1打野无任何关系）：无论是什么样的循环结构，我们一步一步往下算预测他的总操作数，最后得到的肯定是一个关于n的多项式。
也就是说，当n足够大的时候，我们跟天体物理学家一样，基本上算法的差距只剩下数量级能够比较了，**常数系数，比他低阶的n阶项都显得是多么微不足道**，我们按照这个思路，**只保留最nb的N就可以了**，其它都可以忽略了。
- 思路不算困难，但是其实推导对数阶还挺考验数学功底的……像曾嘉轩这种人应该就思考不到这种情况捏。
### 递归的时间复杂度计算（等需要用再好好学）
递归次数（函数调用自身的总次数） x 每次递归消耗的时间颗粒数
### 最坏情况和平均情况：
两项字面意义上都很好理解，但是需要说明的是：**平均情况虽然是一个期望的运行时间，很重要**，但是无法通过数学分析得到，我们计算的大O，*一般也只是分析最坏情况的复杂度*

## 空间复杂度
空间复杂度是对一个算法在运行过程中临时**额外占用存储空间大小的量度** 。并不是说一个程序占用了多少字节他的空间复杂度就是多少。

虽然这也与空间复杂度有关，但毕竟编译器自身编译就自带一大堆的参数，每个编译器在不同系统软件层面都还不太一样，所以文件的占用空间的这个参数就显得不是那么有参考价值

因此空间复杂度主要通过函数运行时**显式申请的额外空间**来确定。表示方法依然是**大O**，原理一直

```c
//example1

void BubbleSort(int* a, int n)
{
	assert(a);
	for (size_t end = n; end > 0; --end)
	{
		int exchange = 0;
		for (size_t i = 1; i < end; ++i)
		{
			if (a[i - 1] > a[i])
			{
				Swap(&a[i - 1], &a[i]);
				exchange = 1;
			}
		}
		if (exchange == 0)
			break;
	}
}
```
这种空间复杂度为O（1），因为他只额外申请了一个变量而已

```c
//example2
long long Fib1(size_t N) 
{
    if(N < 3)
        return 1;
    return Fib(N-1) + Fib(N-2);
}
```
递归递归，先递再归，他这个斐波那契先创造了N个栈，然后再从Fiv1（1）里慢慢返回，其实他就一共额外申请了N个`long long`空间，虽然这个时间复杂度很爆炸（递归次数很多），但是由于**空间能个复用**，像`F（n-2）`这种也是呀全部都算完了才会销毁，所以实际上这个函数的空间复杂度是O（N）

