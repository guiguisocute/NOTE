### 函数
引入：
> 上黄老师的C语言实验课，每次都要写好几坨代码，每次展示的时候都要不停地注释和反注释，这实在是太麻烦了，有什么办法可以化简这个过程吗？

直接用返回值为`void`的函数进行 **“封装”** 直接调用就行：

比如随便从我的作业里面复制三个代码：

```c
#include<stdio.h>
#include<stdlib.h>

int main(){
    int t; int apple[10];
    for(int i = 0; i < 10; i++){
        scanf("%d",&apple[i]);
    }
    scanf("%d",&t); t += 30;

    int count = 0;
    for(int i = 0; i < 10; i++){
        if(apple[i] <= t){
            count++;
        }
      
    }
        printf("%d\n",count);  

        system("pause");
        return 0;

//本应该注释掉
   int kwh;
    scanf("%d",&kwh);

    if(kwh >= 150){
    printf("%.1f",kwh >= 400 ? 150 * 0.4463 + 250 * 0.4663 + (kwh - 400) * 0.5663 : 150 * 0.4463 + (kwh - 150) * 0.4663);
    }else{
        printf("%.1f",kwh * 0.4463);
    }
    system("pause");
    return 0;

//下面这段也是
  int x;
    scanf("%d",&x);
    if(x % 2 == 0 && x > 4 && x <= 12 ){
        printf("1 ");
    }
    else{
        printf("0 ");
    }
    if (x % 2 == 0 || (x > 4 && x <= 12)) {
        printf("1 ");
    } 
    else {
        printf("0 ");
    }
    if ((x % 2 == 0) ^ (x > 4 && x <= 12)) {
        printf("1 ");
    }
    else {
        printf("0 ");
    }
    if(!(x % 2 == 0 || (x > 4 && x <= 12))){
        printf("1 ");
    }
    else{
        printf("0 ");
    }
}
```

现在，我们把这三段完全不一样的代码给分类封装好一个个的“盒子”，但因为盒子里面完全就是机械地执行代码，所有的语句都在“盒子”里就已经定义执行好了，所以其应该被定义为`无参函数`（小括号里面没有东西） 。而且它们没有返回值需求所以也定义成`void` *（`main`函数返回`int`比较特殊,属于一种约定俗成的规定）*。

> 虽然`void`不能接受任何返回值`value`但是还是可以用`return;`这个语句的，也能表示一种“结束”，跟main函数的return 0 差不多的作用。具体后面笔记说吧。

可以直接进行封装：
```c
void box1(){
      int x;
    scanf("%d",&x);
    if(x % 2 == 0 && x > 4 && x <= 12 ){
        printf("1 ");
    }
    else{
        printf("0 ");
    }
    if (x % 2 == 0 || (x > 4 && x <= 12)) {
        printf("1 ");
    } 
    else {
        printf("0 ");
    }
    if ((x % 2 == 0) ^ (x > 4 && x <= 12)) {
        printf("1 ");
    }
    else {
        printf("0 ");
    }
    if(!(x % 2 == 0 || (x > 4 && x <= 12))){
        printf("1 ");
    }
    else{
        printf("0 ");
    }
}
```
函数定义 =（函数声明————→函数实现）
```c
#include <stdio.h>

// 声明函数
int sb(int s);

// 定义 `main` 函数
int main() {
    sb(250);  // 正确调用 `sb` 函数
    return 0;
}

// 定义 `sb` 函数
int sb(int s) {
    printf("%d", s);
    return 0; // 确保与函数类型一致
}
```
函数实现就和调用变量参数一样不用在写个变量类类型了，再写个变量类型显得你很弱智。。。。

就TM直接
```c
box1();
```

#### 函数的参数
```c
void solve(int i,int result){
    for(;i <= 15; i++){
        result += i;
    }
}

int main (){
    int i = 1;
    int result = 0;
    solve(i,result);
    printf("%d",result)
}
```
其中这个 `int a` 就是函数的参数。
由来：？
- 主要是因为函数都是从main函数直接 **搬过去的** 但有时候，因为main函数中，很多变量都是和 **子函数共享** 的，所以如果直接搬过去，就会 **报错** 
- 我们根据报错，必须再这个小括号里面，再加几个小变量，就解决啦，就像上面的示例代码一样，**但是这样虽然解决了编译错误，却解决不了逻辑错误**，实际上，如果还用`void`时，就算再定义了，还是不能把正确的结果给<font color = red>返回</font>给main这又是为什么呢？
</br>
    - 实际上，`main`函数也就是一个 **完全独立** 的 “国家”，与谁独立呢，与所谓的**子函数**（比如solve国）独立，所以，每个国家的“子民”，虽然名字是可能一样，但完完全全是不同的东西，也就是说，在课堂的例子中：**此result非彼result，此i非彼i**
</br>
    - **但怎么要解决呢？**：我们观察一下，发现其实main国的`result`和`i`，可以在调用的时候 **坐飞机**（放进小括号里） 到`solve`国，给`solve`国里面的指令给调教。所以，我们也可以**造一个反向的飞机** 把`solve`国调教过的result也给**重新送回`main`国，**然后再通过赋值语句把`result`从飞机里面接过来** 再让`main`国给`result`进行调教，这也就是，返回（`return`）的由来。
  
```c
void solve(int i,int result){
    for(;i <= 15; i++){
        result += i;
    }
    return result;
}

int main (){
    int i = 1;
    int result = 0;
    solve(i,result);
    printf("%d",result)
}
```
- 改完了，但是沃茨阿尼玛为什么还是不对呢，哦对了，原来是这个船舱的类型没有搞正确，你妈隔壁的一个`void`类型的飞机还能装值的吗，而且你也没赋值把`result`给接回来，怎么给小人国国王调教？
  OK，知道了以后就可以完全改对了：
  
```c
int solve(int i,int result){ //用正确的飞机类型
    for(;i <= 15; i++){
        result += i;
    }
    return result;
}

int main (){
    int i = 1;
    int result = 0;
    result = solve(i,result); //把result给接回来
    printf("%d",result)

    return 0;
}
```

#### 抽象语法树
会画吗？懂得含义吗？区分变量的所属关系吗？对变量边界有研究吗？（最后了【两个问题是啥？）
- **花括号**：有上下级的父子关系
- **同一层级**：兄弟关系

组合起来就变成了（AST（Abstract Syntax Tree）:抽象语法树），程序都是根据AST，做 **深度优先遍历**。
```c
int i = 0
while(i<=5){
    int zz= 1;
    i++;
}
printf("%d",i);
printf("%d",zz);
```
zz只定义在`while`花括弧里面，所以`zz`是与while成父子关系，对于main来说，zz是while的儿子而不是自己的儿子，所以当然这段代码在输出zz的时候，会认为zz没有被定义

**由此可见，这种 人名.国家 的概念，不仅仅只局限于子函数，主函数的关系，还能应用在AST中的所有变量的关系上。**

#### 函数的指针调用
好了，现在我们有了函数这个概念，可以玩些花活了，比如给C语言定义一个能在C++被慵烂的函数`swap();`

然后直接开写！
```c
#include <stdio.h>

int swap(int x,int y){
    int temp = x;
    x = y;
    y = temp;
    return;
}

int main() {
    int x = 1;
    int y = 2;
    swap(x,y);
    printf("%d %d",x,y);
    return 0;
}
```
写到这的时候发现不对劲了：
- 诶我曹，我想要一步到位，但这个`return`好像只能返回一个值只能造一个飞机，但是swap国和main国又不互通swap里面改又没用，难道真的無駄遣いが了吗？
- 没关系，我们还能动用 **盒武器**：
> 手拿`&x`的照片，对着`x`说：宝宝这是你吗？

直接用**赛博界警务通**取地址符`&`，无论你在哪个国，你都能找到内个人，这样，**跨函数（跨国界）的变量交流**就不成问题了

> 但是换个角度去想，如果我所有的功能都不需要在外部调用，全部都写在主函数里面，那么，我也完全不需要去学指针了
> 
> 你想一想，至今做的各种算法基础普及题里面，有哪怕一题是需要硬性要求指针的吗？不就是因为程序小代码量也小嘛，所以如果你要做一个大项目，里面需要各种客制化函数调用来调用去，那么指针肯定是不可缺少的。

- 盒出来以后，发现，变量的地址值是一个 **十六进制的值**，既然是值那就是数据，那么就可以再拓建一个变量格子储存它，C语言甚至给它划分了一个新的名字，专门储存地址（这下真警务通了） 比如`int* pa = &x`
- 有警务通也不够啊，那么我要怎么通过指针找人呢？那么就有 **发逮捕令**操作，通过你家地址直接把你人给揪出来，那就是在**指针变量**前加一个前缀*,就直接把可以把值给弄出来，就比如说这个`swap`函数，毕竟`swap`想要跨国执法调教a和b，就首先要知道a和b在`main`的地址，我们直接用警务通（取地址符&）盒出来，然后再根据这个地址开个逮捕令，之后就能顺利调教了
```c
void swap(int* a,int* b){   //表示这个swap国的飞机只能载警务通开盒开出来的信息（指针或地址），不能真的接受main国的变量，要不然没法跨国执法了，
//注意了，这时候的a和b在main国是一个确切得值，但在swap，只是两串地址！！虽然名字都是一样但代表含义不一样！这个前面也解释过
    int temp;       //这个是swap自家的调教专员，一个临时的牛马，只辅助把开出逮捕令的a和b调教一下，不需要运到main去所以不需要定义成有关地址的形式
    temp = *a;      //用*逮捕令通过盒出来的地址定位到main里的a本人，并且让temp强行等于a。相当于克隆一个a
    *a = *b;        //把B的值赋值到a，等于让b强健了a，a已经完全成为b的样子了！
    *b = *temp;     //因为b已经把a强健了所以a已经成了b的形状了，b想成为a的样子只能找它的克隆体temp去整了。
}

int main(){
    int a = 10; int b = 20;
    swap(&a,&b)     //用警务通&开盒地址，然后装进swap的地址专用运奴船
    print("%d %d",a,b);     //可怜的a和b在自家就被可恶的swap国小人操纵，被迫夺舍了互相！！

    return 0；
    悲惨故事结束
}
```
- 其实也能印出来，当你写的屎山实在太他妈隔壁多了你也不知道自己那个函数是不是指针之类的，那就把函数调用时的参数 **退一格**，值变指针，指针的话再加一颗星，所有东西都，那你就这样吧。
##### 二级指针
指针——两星上将版：通过**警务通**盒出来的地址也是特定的`人`（变量）去记着（存储）的，所以，还能通过&把这个条子再开盒一次，也肯定是能盒出一个地址出来，也就是——**指针的指针**,所以理论上指针的级数都只和性能上限有关，但目前我连二级指针都理解费劲了，所以更高级具体有什么用idk。

- 但是二级指针弄懂了还是能玩玩的！
- 就比如上面的`swap`，虽然可以通过指针直接修改`main`的a和b，但其实可以实现一个更“高级”的对调，就是把 **指针的指向给换了！** ,这样可以在不更改a和b里面的东西的情况下，实现输出的调转。实现代码如下
```c
void swap_doublepoint(int** ppa,int** ppb){     //二级指针的两颗星只体现在这里了
//作用只是作为副本存main国里pa和pb的地址。
    int* temp_p;
    temp_p = *ppa;
    *ppa = *ppb;
    *ppb = temp_p;
}

int main(){
    int a = 10, b = 20;
    int* pa = &a;
    int* pb = &b;
    // swap_singlepoint(&a,&b);
    // printf("单指针swap输出的结果是：%d %d\n",a,b);
    swap_doublepoint(&pa,&pb);
    printf("二级指针法输出的结果是%d %d,但是直接调用a和b输出的结果是%d %d",*pa,*pb,a,b);
    return 0;
}
```
- 由此可见，其实二级指针 **只是一个实现指针指向改变的功能时所带来的结果**，而不是一种装逼的原因，实际编写代码的时候，不是那种，啊我要用二级指针才要先定义个含二级指针的函数balabala的虚假思维。
- BTW: 考试的时候，`实参`就是函数里面自挂的变量，`形参`就是函数参数挂入指针 ~~老八股堆砌概念罢了~~