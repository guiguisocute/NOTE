[^_^]:~~我一直觉得这门课程的衔接性做的非常的差劲，还是把他当做课堂笔记用吧~~
## 概述
---
## 应用层
---

## 传输层

### 传输层的定义与服务
##### Th1:传输层是为*应用层* 提供`服务`的
> 用一种不形象的比喻：传输层类似于两个单位（主机）各自的个人（端）之间数据收发的 *中枢*

传输层的**核心任务**是为`应用` `进程`之间提供 ***端[^1]到端*** 的**逻辑通讯服务**
|主要功能|简单解释|
|----|----|
|传输层寻址|寻找应用程序的端口方法|
|应用层报文的分段与重组||
|报文的差错检测|差错检测依赖于差错编码|
|进程间的端到端可靠数据传输控制|互相发送ACK代码检测可靠性|
|面向应用层的实现复用与分解|复用：分解：|
|端到端的流量控制|因为计算机之间的性能与网络带宽有所差别，传输层必须控制流量以实现数据传输时延的同步|
|拥塞控制|减缓或消除请求数据过多时发生的网络拥堵（Ddos防御）|
##### TH2: 传输层协议只需要在端系统中实现
- 为了高效，以及保证可靠性，传输层只主机应用进程与服务器服务进程的数据交互。



##### Th3: 通信的真正端点并不是`主机`，而是主机中运行的`应用进程`
- 主机与主机的通讯靠网络层来实现
#### 传输层的寻址
- 寻址时的唯一以及统一的标识——端口号
- IP地址+`端口`号可以唯一标识一个全网的通信端点（应用进程）
    - 不同的计算机可以拥有同一个端口号
- 传输层的端口号为16位的整数，包含三类端口：

|端口类型|数值范围（DEC）|注释|
|-------|-------|-----|
|熟知端口|0~1023|IANA给特定常用的*网络协议*&nbsp;所指定的特定的端口（如：HTTP:80）|
|登记端口|1024~49151|服务器端常用，虽然这种进程没有熟知端口号，但也必须在IANA上登记，*以免重复*|
|客户端口号or短暂端口号|49152 ~65535|**不固定**，&nbsp;留给客户端进程选择**暂时**使用|
#### 传输层的复用与分解
`复用`：发送方将**各种不同的进程**所产生的的应用报文封装成对应协议的IP数据段
`分解（分用）`：接收方将对应的IP数据段分解成各种可供**不同的应用进程**使用的应用报文
`多路复用与分解`：是传输层的一项基本功能，支持众多应用进程共用*同一个传输层协议* ，并能够将收到的数据准确交付给不同应用进程
>类似菜鸟驿站，，，
##### 在无连接的多路复用与多路分解（复用与分解的具体实现方式）
UDP的套接字（socket）：<目的地Ip+端口号>
##### 在面向连接的多路复用与多路分解
TCP的套接字（socket）：<标识一条TCP链接>————<源IP地址，端口号，目的IP地址，端口号>

#### 可靠数据传输的基本原理

|实现可靠数据传输的措施|原理|
|----|---|
|差错检测|利用`差错编码`实现数据包传输的差错检测|
|确认|接收方反馈接受状态|
|重传|重新发送接收方没有正确接收的数据|
|序号|确保数据按序提交|
|计时器|解决数据丢失问题以及时延|
实现可靠数据传输的各种协议：
- 停-等协议：主要特点就是发送一段报文后就停下来等待接收方的确认，基本工作过程为：
    1. 发送方经过差错编码和编号的报文段，等待接收方的确认；***发送并等待确认***
    2.  接收方如果正确接收报文段，即差错检测无误且序号正确，则接受报文段，并向发送方发送ACK，否则丢弃报文段，并向发送方发送NAK ***接受并确认/否认***
    3. 发送方如果收到ACK，则继续发送后续报文段，否则重发刚发送的报文段 ***继续发送/重发***
    - 缺点：降低了信道利用率
- 改善停等协议缺陷——流水线协议：
    1. 允许发送方在没有收到确认前连续发送多个分组
    2. 增加分组序号范围
    3. 发送方and/or接受方必须*缓存* 多个分组
        - 典型的流水线协议————`滑动窗口协议`（只是一个种类，不具体到某个实现）
![滑动窗口协议图解](https://cdnimg.acgget.com/images/202104/52bef8fd183f0501.png)

### 经典滑动窗口协议
由窗口的大小决定
- 回退N步协议（GBN）
发送端窗口较大，**但接收窗口只有1**，未按序到达的分组或某个分组差错，就会引起发送发重发该分组及其之后的分组。

- 选择重传协议（SR）
**增加接收方的缓存能力**，缓存正确但失序的分组，仅要求发送方重传未被接受方确认的分组，等缺失分组到达后一并向上层按序提交

#### 管道协议



    
#### 无连接服务与面向连接服务
##### 无连接服务
不经过握手[^2]，直接构造传输层报文并向接收端发送
——`UDP`协议（用户数据报协议）属于这项服务
支持信息的单播多播广播
直接把应用层发送的应用层报文原封不动传输过去加上首部
*面向应用报文的*
实际上UDP的接收方也是有传输层的基本的差错检测，但就算是检测到了误码，发送方也不会做什么

总之UDP向上层提供无连接不可靠的传输服务，但是因为这种特性，速度会比TCP传输速度要快，适用于IP电话视频会议等**实时应用**
#### UDP的首部格式
UDP首部**仅8个字节**
|源端口号|目的端口号|长度|校验和|
|:---:|---|---|----|---|-|
|4（字节）|4|4|4|
|源端口号。在需要对方回信时选用。不需要时可用全0|目的端口号。这在终点交付报文时必须要使用到| UDP用户数据报的长度，其最小值是8（仅有首部），发送一个带0字节数据的UDP数据报是允许的*|检测UDP用户数据报在传输中是否有错。有错就丢弃|
\*：值得注意的是，UDP长度字段是冗余的；IPV4头部包含了数据报的总长度，同时IPV6头部包含了负载长度。因此，一个UDP/IPV4数据报的长度等于IPV4数据报的总长度减去IPV4头部的长度。一个UDP/IPV6数据报的长度等于包含在IPV6头部中的 *负载长度*（payload length）字段的值减去所有扩展头部（除非使用了超长数据报）的长度。这两种情况下，UDP长度字段应该与从IP层提供的信息计算得到的长度是一致的。
#### 伪首部

UDP的计算校验

*“不可靠”传输*
##### 有链接服务（TCP）
数据传输之前，需要交换控制信息，通过**三报文握手**建立*逻辑链接*（物理连接） ，然后  **再**传输数据，结束后还需要使用**四报文挥手**来**拆除**链接
全双工^[3]通信
——`TCP`（传输控制协议）协议属于这项服务
不管应用报文的语义，只把他看作是一段一段的**字节流**再加上TCP特定的标识符
*面向字节流*
**仅支持单播**
TCO首部**至少**20个字节，至多60个
#### TCP首部

![](https://gitee.com/sinkinben/pic-go/raw/master/img/20210223144344.png)
确认号：

序号：对字节流的**编号**，而且非常简单，一个多的字节就是序号+1，（比如第一个字节编号是201，携带100字节，那么下一个报文段就是301）保证接受数据的顺序，保障可靠数据传输的重要保障

确认号：返回确认信息所携带的规则定义~~~接收方：这个序号之前的我已经都收完啦~~~

数据偏移：TCP报文会依然被分解成小段，用数据偏移的字段告诉重新复用所采用的协议和hash；

URG：就是紧急指针，意为URG位有效的（=1？）数据包，是一个**紧急需要处理的数据包**，需要接收端在接收到之后迅速处理。越过缓冲区交付给应用层

ACK：确认码的通信，并且规定如何确接收到的是哪块代码流

PSH：push位，加急比特，通知加速传输，并将带PSH位有效数据的所有报文都发送到接收端的**缓冲区**，并将缓冲区的数据全部交给上一层（应用层）

SYN：sync同步位，确认另一发发起的链接“同步请求”的编号

FIN：finish位，拆除链接的确认码

数据偏移：指的是数据字段距离起始的偏移量，实际上指的是**首部长度**

窗口：缓存的大小（类似滑动窗口，可变），用于实现流量控制和拥塞管控

校验和：与UDP同理

选项：最大报文量长度加各种
填充：使得整个首部大小固定四字节的倍数的填充（作用难道就是凑字数吗？有点离谱的）
**TCPIP**链接管理必须掌握的知识↑
**链接建立**：
三次握手：
![](https://gitee.com/sinkinben/pic-go/raw/master/img/20210223145132.png)
*sep为上述的序号，ack（小写）为上述的确认号
1. SYN连接请求（必须是C2S同步请求），C端发送了完整的TCP的报文，所有的顺序编号全部由C端所自行定义
2. SYN确认（S2C），S端传输数据时连带着确认发送的同步信息，顺便在发一个ACK确认保证最佳的可靠性
3. ACK确认(双方)
4. 数据的传输（必须按照规定好顺序传输，此时已是链接建立完毕的状态了）

**链接拆除（释放带宽和缓存内存）**
四次挥手，进行四次的数据的交换。
1. 链接释放的请求FIN=1（可C可S）
2. ACK确认（收到FIN，并且“半关闭”，如果数据传输还没完成，还可以继续传输）
3. 传输完了，另外一方发送FIN=1(注意此时的数据编号和上一步一致)
4. 发送收到FIN的ACK，进入time_wait时延等待最终的确认

#### TCP为什么可靠
通过差错编码，确认，序号，重传，计时器等各种编码多重确认
重传前面的三个前面都已经讲过了嗷，现在来看看重传和计时器的
#### 计时器超时重传
TCP使用基于滑动窗口协议的超时重传进行可靠传输———如果一个报文段超时时间内没有收到确认，则进行重传

一个报文段从发送再到接收到确认所经过的时间称为往返时间 RTT 。

TCP 保留了 RTT 的一个加权平均往返时间 RTTs（这又称为平滑的往返时间）。第一次测量到 RTT 样本时，RTTs 值就取为所测量到的 RTT 样本值。以后每测量到一个新的 RTT 样本，就按下式重新计算一次 RTTs ：

(NewRTTs)=(1−α)∗(OldRTTs)+α∗RTT
式中，0≤α<1。若 α 很接近于零，表示 RTT 值更新较慢。若选择 α 接近于 1，则表示 RTT 值更新较快。RFC 2988 推荐的 α 值为 0.125。

超时时间 RTO 应该略大于  RTTs ，TCP 使用的超时时间计算如下：

RTO=RTTs+4∗RTTd
RTTd 是 RTT 的偏差的加权平均值。
#### 流量控制
接收方通过将窗口字段设置为0来实现流量控制，使得接收方能“来得及”接受
接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。
（窗口字段怎么发是这一节的重点）


#### 拥塞控制
拥塞：在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，分组会丢失，发送方会重传，网络性能就要变坏。这种情况就叫做拥塞（congestion）
- 如果不进行控制，吞吐量随着负载的增大而下降

如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度

拥塞窗口（cwnd）: 只是一个状态窗口，实际上决定发多少还是发送方的发送窗口。

TCP的动态窗口：
通过的调节窗口的大小实现对发送数据速率的调整。
AIMD（加性增加，乘性减小）
解释：未发生拥塞时，逐渐加性增大窗口大小，网络拥塞时乘性快速减小窗口大小
算法：慢启动，拥塞避免，快速启动快速恢复。

`ssthresh`（慢开始阈值）

拥塞窗口的控制可以以简记为 2 个阶段以及 2 个处理方法：

2 个阶段：
- 慢开始，cwnd 指数增长；
- 拥塞避免阶段，线性增长。

2 个处理：
- 如果出现超时，表明网络出现拥塞，那么 `ssthresh = cwnd / 2, cwnd = 1` .
- 如果出现 3-ACK，表明出现丢包，那么 `ssthresh = cwnd / 2, cwnd = ssthresh` .

**快重传和快恢复**
在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认。例如已经接收到 M1 和 M2，此时收到 M4，应当发送对 M2 的确认。

在发送方，如果收到三个重复确认，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。例如收到三个 M2，则 M3 丢失，立即重传 M3 。对应上述图中第 4 个拐点 4⃣️ 。

在这种情况下，只是丢失个别报文段，而不是网络拥塞。因此执行快恢复，令 ssthresh = cwnd / 2, cwnd = ssthresh，注意到此时直接进入拥塞避免。对应上述图中第 5 个拐点 5⃣️

*“可靠”传输*
#### 传输层的差错检测
---
### 2021年5月17日08:40:06


[^1]:端：指进程，进程使用PID来标识，但操作系统各有不同PID也各有不同，因而使用端口号在TCP/IP体系下标识
[^2]:握手：在数据通信中，由硬件或软件管理的事件序列，在进行信息交换之前，需要对操作模式的状态互相达成协定。在接收站和发送站之间建立通信参数的过程。
[^3]:双工通信，广播：单工；邮件：半双工；电话：全双工
---



