## 数制
#### 预备概念
- **基：** 二进制的基为二，八进制的基为八，十进制的基为十，十六进制的基为十六，以此类推。
<br>
- **位权：** <font color=red>从小数点开始</font>，依次向左右两边**用基的指数**编号，向左为0, 1, 2，…,向右为-1，-2，-3，…。
以二进制为例
从小数点开始，向左位权依次为：
2^0^，2^1^，2^2^
向右位权依次为：
2^-1^，2^-2^
其他进制以此类推
<br>
- **数码：** 各数制中每一个单独的数字就是它的一个数码
---
### 常用数制的简单简单描述：
- **十进制（DEC）——** 逢十进一，人类之中拥有绝对统治力的进制*，无论是现代还是古典的数学上的默认进制
- **二进制（BIN）——** 逢二进一，只有01，数字电路内核中最常用的进制，用0和1代表各种元件中两种截然不同的稳定状态（比如开关或者动停）提高可靠性和抗干扰能力，加上0和1刚好对应逻辑学中的false与true，这些都是选用二进制最根本的原因
- **八进制（OCT）——** 逢8进一，在计算机的早期时代，为了更简洁地表达出二进制而产生的特殊数制，一位八进制数可以映射为三位二进制
历史上八进制的广泛应用主要是在12-bit、24-bit和36位的机器上。在如今32-bit，64-bit盛行的时代，肯定不如十六进制。
现在八进制的主要应用应该是在处理UTF-8编码和Linux 文件权限或者某些文件结构中的数据存储方式上
- **十六进制（HEX）——** 逢16进一，大于9的基数则使用英文大写字母A~F来代替，用法以及来源跟二进制相同，是目前计算机操作系统中最广泛使用的精简二进制串的数制


>*：十进制为什么在全世界的数学领域都具有绝对的统治力是因为阿拉伯数字的全球流行（为什么全球流行是因为各个地区古代的主流文化包括华夏欧洲伊斯兰都不约而同的使用了十进制作为最基础的数制，大概因为是人有十根手指的原因），不代表其在**任何环境**都具有优势，比如计算机中的数制就是以2的次方为基础的数制进行表达

**不同进制数的对照表：**
![](https://img-blog.csdnimg.cn/20200629190325638.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDM3ODgzNQ==,size_16,color_FFFFFF,t_70)

---
### 数制的转换
#### 2^n^进制和二进制的互换

>八进制和十六进制的广泛使用就是为了更方便的在计算机系统内表达大量的二进制串，这三个之间的互转就是现在常用数值里最简单的，这是因为无论八进制还是十六进制，他们的**基**都是二的整数次方，所以说，就算有更高（32进制）或者更低的（4进制），他们都遵守着同样的规律：

**二进制转2^n^进制**
1. 将二进制**从右向左，每n位*一组（不足n位左补0）**，分完组后**正序输出**
2. 再将**每个n位数码组**根据对照表转化成**单个的**2^n^进制数码
3. 再将每个2^n^进制数码**正序输出**

**2^n^进制转二进制**
1. 将每个2^n^进制数码都转化成对应的**n个二进制数码**
2. 去掉首部多余的0，然后**正序输出**

`example：`
```
将二进制（1101011111011）转换为八进制
解：
1.（001，101，011，111，011）   //分三位一组
2. （1，5, 3，7,3） //将每个分组转换成单位的八进制数码
3. 得出结果：（15373）  //将每个八进制数码正序输出  

将十六进制（d7de3）转换位二进制
1. （1101,0111,1101，1110，0011）   //将每个十六进制数码都转化成对应的4个二进制数码
2. 得出结果（11010111110111100011） //去掉首部多余的0，然后正序输出
```
#### 十进制和各种进制的互换
**非十进制转十进制**
- 方法：按权展开相加

如将 (11010.101)2写成权展开式为：
![](https://img-blog.csdnimg.cn/20200629190749553.png)
~~虽然很想用精确的语言来解释，但想了想还挺费脑子的，反正这个笔记也就曾嘉轩看，不如举例子他自己融会贯通就完事了~~

**十进制转非十进制**
- 整数部分
    - 不断整除基数取余，然后倒序输出
```c
//尝试着用codes解释
#include<iostream>
using namespace std;
int main()
{
	int ji, item, k, c, i=0;
	int a[1000];
	cout << "please enter the decimal number:" << endl;
		cin >> item;
	cout << "please enter the cardinal you want to convert:" << endl;
		cin >> ji;
	while (item >= ji)
	{
		k = item % ji;
		item /= ji;
		a[i]=k;
		i++;

	} 	
	a[i] = item;
	cout << "the result is:";
	for (int j = i; j >= 0; j--)

	{

		c = a[j];
		cout <<c;

	}
	return 0;
}
//庆祝一下自己第一个包含实例的程序
```
- 小数部分
    - 只把小数部分提出来，不断递归乘基数直到不在存在小数部分（小数点右边不含值）

```c
//完整code演示
#include<iostream>
using namespace std;
int main()
{
	int ji, item, k, c, d, i = 0, z = 0;	double temp, xiaoshu;
	int a[1000], b[1000];
	cout << "please enter the decimal number:(float is OK)" << endl;
	cin >> temp;
	cout << "please enter the cardinal you want to convert:" << endl;
	cin >> ji;
	xiaoshu = temp - int(temp);
	item = int(temp);
	
	while (item >= ji)	//整数部分的输出
	{
		k = item % ji;
		item /= ji;
		a[i] = k;
		i++;

	}
	a[i] = item;
	cout << "the result is:";
	for (int j = i; j >= 0; j--)

	{

		c = a[j];
		cout << c;

	}
	cout << ".";
	double dji = ji;
	while (xiaoshu-int(xiaoshu)!=0)	//小数部分的逻辑
	{
		k = int(xiaoshu*ji);
		xiaoshu *= dji;
		xiaoshu = xiaoshu-int(xiaoshu);
		b[z] = k;
		z++;
		if (z >= 10)	//保留小数的地方
			break;
	}
	for(int m = 0; m!= z ;m++)
	{
		d = b[m];
		cout << d;

	}
	return 0;
}
```
- 注意：此程序只能处理10以下的进制的转换，十以上的得对特定数码进行宏定义
---
###　二进制的算术运算
当两个二进制数码表示两个数量的大小，并且这两个数进行数值运算，这种 运算称为算术运算。算术运算包括“加减乘除”，**但在二进制中，减、乘、除最终都可以化为带符号的*加法运算*。**
#### 算术运算

- 和十进制算数运算的规则相同
- 逢二进一、借一当二
- 特点：加、减、乘、除 全部可以用移位和相加这两种操作实现。简化了电路结构

所以数字电路中（也就是计算机中）普遍采用二进制算数运算

**二进制中的加法规则**
![](https://img-blog.csdnimg.cn/20200629211852333.png)
**二进制中的减法规则**
![](https://img-blog.csdnimg.cn/20200629211940667.png)

实际上如果真要0-1的话还是会等于-1的，但关于为什么这张图里面的是0-1=1
>0-1=1是指本位，不考虑借位的情况。
例如1位十进制数，其范围是0~9，我们从9开始，不断减1，就会得到8、7、6......，但减到0的时候，再继续减1会怎样呢？若不考虑向高位的借位情况，只看本位：0-1=9。
这与二进制数运算中0-1=1是类似的。

**二进制乘法规则**
![](https://img-blog.csdnimg.cn/20200629211949999.png)
手算：换成十进制再乘
计算机算：用补码运行（具体后面再讲）
**二进制的除法规则**
![](https://img-blog.csdnimg.cn/20200629212015310.png)
>有一说一不管什么进制都是逢x进1那一套，都可以用十进制教的乘法除法无限套,只要注意别把逢十进一氪金DNA里就行

### 原码-反码-补码
#### 前置知识
- **机器数**————绝大部分计算机存储二进制的一个特殊的“协议”，即————用一个数（二进制）的*最高位*来表示该数据的正负，1为负，0为正。
	- 比如，十进制中的数 +3 ，**计算机字长为8位**，转换成二进制就是00000011。如果是 -3 ，就是 10000011
	此例子中的00000011和10000011就是机器数
- **真值**————为区别起见，将带符号位的机器数对应的真正数值称为机器数的真值
---
#### 原码
原码的表示方式为：

- 原码就是符号位加上真值的绝对值,
-  即用第一位表示符号, 其余位表示值。数值上和机器数相等，~~不过它们两个倒是不同领域的概念就是了~~
原码最容易让人所理解
#### 反码
反码的表示方法是:

- 正数的反码是其本身

- 负数的反码是在其原码的基础上, 符号位不变，其余各个位取反。

>[+1] = [00000001]原 = [00000001]反
[-1] = [10000001]原 = [11111110]反


- 所以负数的反码属实不好判断数值
#### 补码
补码的表示方法是:

- 正数的补码就是其本身

- 负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1. (即在反码的基础上+1)(正所谓**补**)
>[+1] = [00000001]原 = [00000001]反 = [00000001]补
[-1] = [10000001]原 = [11111110]反 = [11111111]补


---
### 三码的作用
>建议：**首先先把概念给“死记硬背下来”，再来分析**

虽然在人脑中，直观的真值计算会比非常不直观的反码补码计算方便很多很多，但那是因为人脑的“电路”已经默认包含了加减乘除的默认法则。但是计算机没有这种“出厂自带”，如果再加一个减法器，电路的复杂程度就会直接提升几个指数级，这是现在人类~~intel设计师~~无法接受的，因此不直观但能把所有的减法化成加法的补码与反码尤为重要！




























note：
数码：未进位的最大表示值
基：最小的进位dec整数
权：数学意义上的权

dec小数转换
小数部分乘2取整顺排

二进制的各种转换
每n位一组，从右往左输出

原码：原来的二进制
反码：符号位不变，其他的倒序输出
补码：最低位加一