## 数据结构
> **`数据结构` + 算法 = 程序** ————by pascal founder 尼古拉沃斯

### 算法
算法计算机导论讲过了，抽象的，不直接的，能用自然语言，流程图，编程语言共同描述的一种 **方法论**。

最常见研究的表示方法————`伪代码`（*论文算法的表述方法*）

#### 算法追求的目标
（以下金字塔重要性排序）
- 正确性
- **时间复杂度**更低，所需运行时间更小 
- **空间复杂度**更低，所需内存空间更小
- **可读性**，方便自己和他人阅读 ~~主要是给砸自己看哈，要不然就变成屎山了~~

### 数据结构
**数据结构**：简而言之，数据结构是 **存放数据** 的方式，而算法是处理这些数据的方法。
> - 数据结构就像工具箱中的各种工具，比如锤子、螺丝刀、扳手等。每种工具都有它特定的功能：锤子用来敲打、螺丝刀用来拧螺丝、扳手用来拧螺母……在数据结构里，不同的结构（比如数组、链表、栈、队列、树等）就像这些工具，提供了存储和组织数据的方式。——————by GPT 4o

因此，精心选择的数据结构 **配上正确且合适的算法** <font color = red>可以带来更高的运行效率和空间存储效率</font>，

#### 数据的逻辑结构
- **集合**： 【数组】
- 线性结构
- 树形结构
- 图形结构
#### 数据的存储结构：
 **一种逻辑结构可能需要采用多钟存储数据结构**，存储结构可分为**连续存储**和**分散存储**。

顺便补一个内存地址的知识

**连续存储**：存储器中的 **相对位置** 代表逻辑关系 （代表表现：`数组`）
**分散数组**：借助 **指针** 表示数据之间的逻辑关系（代表表现形式：`链表`）

#### 数据的操作

对具体数据元素进行的运算或处理的 **基础操作形式**
- 具体的实现依赖于数据的存储结构————————→所以每种逻辑结构都有一组对其数据元素进行处理以实现特定功能的操作。
- 常见的有以下：
##### CURD

CRUD 是四个基本操作的首字母缩写，分别表示：

1. **C - Create（创建）**：添加新数据，比如在数据库中插入一条新的记录。
  
2. **R - Read（读取）**：查询或读取数据，比如从数据库中读取某条记录或数据列表。
  
3. **U - Update（更新）**：修改现有数据，比如更新数据库中的记录内容。
  
4. **D - Delete（删除）**：删除数据，比如从数据库中删除一条记录。

这些操作是数据库管理、API设计、应用开发中的核心操作，涵盖了数据的增删改查（即创建、读取、更新和删除）功能。

#### 数组
数组为数据分配 **连续的内存块**， 无须额外的结构开销。并且允许在O（1）时间内访问任意元素

并且当访问数组元素，计算机不经会加载它本身，**还会缓存其周围的其他数据**，所以速度也就牛逼上来了。（*提高了“命中率 ”*） [访问的时候把整个数据块都放进三缓里了]。这也是其和`链表`最基础的区别。

但同时，连续存储带来的缺点也很致命：
- **插入和删除效率低**：中间遍历一下就老实了。
- > 计算机很几把蠢，如果从一个已初始化的数组的 **中间** 插入一个新的元素，那么就得需要将钙元素之后的所有元素都后移，然后再补，同理，删除也一样
- **长度不可变** 就算是`vector`,`macor`,也只是饶了一个弯子，先提前开辟了数组，没改变本质
- **空间浪费** ：喜欢我`char s[10000001]`吗？

##### 动态数组（C）
使用`maclloc`进行创建，和`realloc`进行“编辑”，下面是一个声明动态数组赋值，改变大小的一点示例，可以作为学习的参考：
```c
#include <stdio.h>
#include <stdlib.h>

int main() {
    int initialSize = 5;
    int *dynamicArray;

    // 1. 使用 malloc 分配初始内存
    dynamicArray = (int*)malloc(initialSize * sizeof(int));
    if (dynamicArray == NULL) {
        printf("Memory allocation failed.\n");
        return 1; // 分配失败
    }

    // 2. 初始化数组元素
    for (int i = 0; i < initialSize; i++) {
        dynamicArray[i] = i + 1;
    }

    // 输出初始数组
    printf("Initial array: ");
    for (int i = 0; i < initialSize; i++) {
        printf("%d ", dynamicArray[i]);
    }
    printf("\n");

    // 3. 使用 realloc 扩展数组大小
    int newSize = 10;
    int *tempArray = (int*)realloc(dynamicArray, newSize * sizeof(int));
    if (tempArray == NULL) {
        printf("Memory reallocation failed.\n");
        free(dynamicArray); // 释放原始内存
        return 1;
    }
    dynamicArray = tempArray;

    // 初始化新添加的元素
    for (int i = initialSize; i < newSize; i++) {
        dynamicArray[i] = i + 1;
    }

    // 输出扩展后的数组
    printf("Resized array: ");
    for (int i = 0; i < newSize; i++) {
        printf("%d ", dynamicArray[i]);
    }
    printf("\n");

    // 4. 释放内存
    free(dynamicArray); //C语言的特点：手动分配，手动回收。
    //但是忘记回收也就是一点浪费空间，对于纯过题来说，基本没啥副作用
    //但在项目开发中，很容易造成内存泄露的情况（而且非常普遍）

    //像后时代的高级语言，pythonjava这种，编译系统会自动检测没用的变量然后进行回收（垃圾回收机制）

    return 0;
}

```
> 例题：P3613 寄包柜
> 

#### 链表
**数据结构的重中之重**

- 分块的数据结构，每一个元素是一个节点对象，各个节点通过 **指针** 链接
- 根据上一条可知道，链表可以不需要一整块的内存块，可以完全分散开
- 而且，删除，添加数据，时间复杂度极低，不会像数组一样需要从头遍历。

但这就完美无缺了吗？并不是，由链表的指针基本性能明白：**链表完全不支持像数列那样按索引号直接访问**，程序需要**从头节点**出发，逐个向后遍历，直至找到目标节点，时间复杂度为O（n），所以要避免去搜索

并且查找相对数组也没有优势，也是O（n），元素占用还要再开一个指针数组，所以元素占用内存也多。

**所以说也不存在包打**

例题：
![alt text](image.png)



- 如果最后指针指向为`NULL`那么正常来时该节点为尾节点，~~就算不是尾结点，也必须要返回为空了~~
一个一个往后指 `head = head -> next;`

- **单向链表**：还用说吗
- **环形链表**
- **双向链表**：


##### 面向对象
- new出来后手里拿不住本身元素，只能拿到他的地址




