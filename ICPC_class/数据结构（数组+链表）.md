## 数据结构
> **`数据结构` + 算法 = 程序** ————by pascal founder 尼古拉沃斯

### 算法
算法计算机导论讲过了，抽象的，不直接的，能用自然语言，流程图，编程语言共同描述的一种 **方法论**。

最常见研究的表示方法————`伪代码`（*论文算法的表述方法*）

#### 算法追求的目标
（以下金字塔重要性排序）
- 正确性
- **时间复杂度**更低，所需运行时间更小 
- **空间复杂度**更低，所需内存空间更小
- **可读性**，方便自己和他人阅读 ~~主要是给砸自己看哈，要不然就变成屎山了~~

### 数据结构
**数据结构**：简而言之，数据结构是 **存放数据** 的方式，而算法是处理这些数据的方法。
> - 数据结构就像工具箱中的各种工具，比如锤子、螺丝刀、扳手等。每种工具都有它特定的功能：锤子用来敲打、螺丝刀用来拧螺丝、扳手用来拧螺母……在数据结构里，不同的结构（比如数组、链表、栈、队列、树等）就像这些工具，提供了存储和组织数据的方式。——————by GPT 4o

因此，精心选择的数据结构 **配上正确且合适的算法** <font color = red>可以带来更高的运行效率和空间存储效率</font>，

#### 数据的逻辑结构
- **集合**： 【数组】
- 线性结构
- 树形结构
- 图形结构
#### 数据的存储结构：
 **一种逻辑结构可能需要采用多钟存储数据结构**，存储结构可分为**连续存储**和**分散存储**。

顺便补一个内存地址的知识

**连续存储**：存储器中的 **相对位置** 代表逻辑关系 （代表表现：`数组`）
**分散数组**：借助 **指针** 表示数据之间的逻辑关系（代表表现形式：`链表`）

#### 数据的操作

对具体数据元素进行的运算或处理的 **基础操作形式**
- 具体的实现依赖于数据的存储结构————————→所以每种逻辑结构都有一组对其数据元素进行处理以实现特定功能的操作。
- 常见的有以下：
##### CURD

CRUD 是四个基本操作的首字母缩写，分别表示：

1. **C - Create（创建）**：添加新数据，比如在数据库中插入一条新的记录。
  
2. **R - Read（读取）**：查询或读取数据，比如从数据库中读取某条记录或数据列表。
  
3. **U - Update（更新）**：修改现有数据，比如更新数据库中的记录内容。
  
4. **D - Delete（删除）**：删除数据，比如从数据库中删除一条记录。

这些操作是数据库管理、API设计、应用开发中的核心操作，涵盖了数据的增删改查（即创建、读取、更新和删除）功能。

#### 数组
数组为数据分配 **连续的内存块**， 无须额外的结构开销。并且允许在O（1）时间内访问任意元素

并且当访问数组元素，计算机不经会加载它本身，**还会缓存其周围的其他数据**，所以速度也就牛逼上来了。（*提高了“命中率 ”*） [访问的时候把整个数据块都放进三缓里了]。这也是其和`链表`最基础的区别。

但同时，连续存储带来的缺点也很致命：
- **插入和删除效率低**：中间遍历一下就老实了。
- > 计算机很几把蠢，如果从一个已初始化的数组的 **中间** 插入一个新的元素，那么就得需要将钙元素之后的所有元素都后移，然后再补，同理，删除也一样
- **长度不可变** 就算是`vector`,`macor`,也只是饶了一个弯子，先提前开辟了数组，没改变本质
- **空间浪费** ：喜欢我`char s[10000001]`吗？

##### 动态数组（C）
使用`maclloc`进行创建，和`realloc`进行“编辑”，下面是一个声明动态数组赋值，改变大小的一点示例，可以作为学习的参考：
```c
#include <stdio.h>
#include <stdlib.h>

int main() {
    int initialSize = 5;
    int *dynamicArray;

    // 1. 使用 malloc 分配初始内存
    dynamicArray = (int*)malloc(initialSize * sizeof(int));
    if (dynamicArray == NULL) {
        printf("Memory allocation failed.\n");
        return 1; // 分配失败
    }

    // 2. 初始化数组元素
    for (int i = 0; i < initialSize; i++) {
        dynamicArray[i] = i + 1;
    }

    // 输出初始数组
    printf("Initial array: ");
    for (int i = 0; i < initialSize; i++) {
        printf("%d ", dynamicArray[i]);
    }
    printf("\n");

    // 3. 使用 realloc 扩展数组大小
    int newSize = 10;
    int *tempArray = (int*)realloc(dynamicArray, newSize * sizeof(int));
    if (tempArray == NULL) {
        printf("Memory reallocation failed.\n");
        free(dynamicArray); // 释放原始内存
        return 1;
    }
    dynamicArray = tempArray;

    // 初始化新添加的元素
    for (int i = initialSize; i < newSize; i++) {
        dynamicArray[i] = i + 1;
    }

    // 输出扩展后的数组
    printf("Resized array: ");
    for (int i = 0; i < newSize; i++) {
        printf("%d ", dynamicArray[i]);
    }
    printf("\n");

    // 4. 释放内存
    free(dynamicArray);

    return 0;
}

```
> 例题：P3613




